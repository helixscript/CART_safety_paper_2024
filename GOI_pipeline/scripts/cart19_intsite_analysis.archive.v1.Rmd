---
title: |
    | CART19 Integration Site Analysis:
    | Manuscript Figures
author: "Christopher Nobles, Ph.D. and Frederic Bushman, Ph.D."
date: "generated `r Sys.Date()`"
output: 
  pdf_document:
    latex_engine: xelatex
    toc: true
    number_sections: false
    toc_depth: 2
    fig_caption: true
    df_print: default
    highlight: espresso
header-includes: 
  - \usepackage{float,indentfirst,booktabs,longtable,array,multirow,pdflscape,tabu}
  - \usepackage[normalem]{ulem}
  - \setlength{\defaultaddspace}{0em}
  - \setlength{\parindent}{2em}
fontsize: 11pt
geometry: margin=0.5in
---

```{r setup, include=FALSE}
options(stringsAsFactors = FALSE, scipen = 99)

packs <- c(
  "BiocGenerics", "Biostrings", "GenomicRanges", "geneRxCluster", "hiAnnotator",
  "igraph", "Matrix", "parallel", "reldist", "reshape2", "RMySQL", "data.table",
  "sonicLength", "vegan", "lubridate", "gintools", "spraphal", "ggrepel", 
  "scales", "grid", "gridExtra", "RColorBrewer", "knitr", "magrittr", "pander",
  "KEGGREST", "GO.db", "UpSetR", "BiasedUrn", "foreach", "tidyverse")

packsLoaded <- suppressMessages(
  sapply(packs, require, character.only = TRUE)
)

if( !all(packsLoaded) ){

  pandoc.table(data.frame(
      "R-Packages" = names(packsLoaded), 
      "Loaded" = packsLoaded, 
      row.names = NULL
  ))
  
  stop("Check dependancies.")
  
}

knitr::opts_chunk$set(
  echo = FALSE,
  fig.path = file.path(workingDir, "reports", "manuscript_figures/"),
  fig.align = "center",
  comment = "",
  echo = FALSE,
  warning = FALSE,
  error = TRUE,
  message = FALSE,
  cache = FALSE,
  dpi = 100,
  dev = "pdf",
  results = "asis",
  fig.pos = "H",
  fig.width = 7.5
)

## Processing information ----
genomicFreeze <- "hg38"

analysisDate <- Sys.Date()

trial <- "CART19"
std_clin_trials <- c("959", "04409", "03712")

set.seed(1234)

## Reference and supporting files ----
source(file.path(scriptDir, "supporting_functions.R"))
source(file.path(scriptDir, "supporting_goa_functions.R"))
source(file.path(scriptDir, "GenomicHeatmapMaker/utils.R"))
source(file.path(scriptDir, "EpigeneticHeatmapMaker/utils.R"))

## Import HGNC reference data for annotation and consistency ----
hgnc_complete <- fread(
  paste0("zcat ", file.path(utilsDir, "hgnc_complete_set.180207.txt.gz")),
  sep = "\t", header = TRUE, 
  select = c(
    "HGNC ID", "Approved Symbol", "Approved Name", "Locus Group", "Locus Type", 
    "Synonyms", "Previous Symbols", "Entrez Gene ID", "Ensembl Gene ID", 
    "RefSeq (supplied by NCBI)", "UniProt ID (supplied by UniProt)"),
  data.table = FALSE
)

names(hgnc_complete) <- c(
  "hgnc_id", "symbol", "name", "locus_group", "locus_type", "alias_symbol", 
  "prev_symbol", "entrez_id", "ensembl_gene_id", "refseq_accession", 
  "uniprot_ids"
)

hgnc_complete <- dplyr::filter(hgnc_complete, !grepl("withdrawn", symbol)) %>%
  dplyr::mutate(
    kegg_id = paste0("hsa:", entrez_id),
    entrez_id = paste0(entrez_id, ":EZID"),
    alias_symbol = gsub(", ", "|", alias_symbol),
    prev_symbol = gsub(", ", "|", prev_symbol),
    extended_alias = paste0(
      alias_symbol, "|", prev_symbol, "|", ensembl_gene_id, "|", 
      refseq_accession, "|", uniprot_ids)
  )

## Setup gene sets and lists ----
key_gois <- c("TET2")

intsiteSpecimenMetadata <- read.csv(
    file.path(workingDir, "data/cart19_intsite_sample_list.csv")) %>%
  dplyr::mutate(clin_trial = str_extract(Patient_ID, "[0-9]+"))

refGenes <- readRDS(file.path(utilsDir, "hg38.refSeq.rds"))

refGenes <- refGenes[
  seqnames(refGenes) %in% paste0("chr", c(1:22, "X", "Y", "M"))
]

refGenes$name2 <- alias_arbiter(
    IDs = refGenes$name2, 
    RefIDs = hgnc_complete$symbol,
    aliasIDs = hgnc_complete$extended_alias,
    sep = "|", remove_absent_IDs = NULL, quiet = TRUE
  )

excluded_gene_names <- c(
  "TET2-AS1", "HNRNPUL2-BSCL2", "ANKHD1-EIF4EBP3", "TONSL-AS1", 
  "ATP6V1G2-DDX39B", "C7orf55-LUC7L2"
)

excluded_sites <- c("PCCA" = "chr13-100350286", "NRP1" = "chr10+33114980")

oncoGenesData <- read.delim(
  file.path(utilsDir, "allOnco.human.v3.tsv"),
  header = TRUE, 
  sep = "\t",
  stringsAsFactors = FALSE
)

oncoGenes <- unique(oncoGenesData[,"symbol"]) %>%
  alias_arbiter(
    IDs = ., 
    RefIDs = hgnc_complete$symbol,
    aliasIDs = hgnc_complete$extended_alias,
    sep = "|", remove_absent_IDs = NULL, quiet = TRUE
  )

nonOncoGenes <- unique(refGenes$name2[!refGenes$name2 %in% oncoGenes])

tum_sups <- read.delim(file.path(utilsDir, "TSGene.tsv"))$GeneSymbol %>%
  alias_arbiter(
    IDs = ., 
    RefIDs = hgnc_complete$symbol,
    aliasIDs = hgnc_complete$extended_alias,
    sep = "|", remove_absent_IDs = NULL, quiet = TRUE
  )

badActors <- read.delim(
    file.path(utilsDir, "humanLymph.v1.list"),
    header = FALSE,
    sep = "\t",
    stringsAsFactors = FALSE
  )[,1] %>%
  alias_arbiter(
    IDs = ., 
    RefIDs = hgnc_complete$symbol,
    aliasIDs = hgnc_complete$extended_alias,
    sep = "|", remove_absent_IDs = NULL, quiet = TRUE
  )

if( file.exists(file.path(utilsDir, "COSMIC_cancer_gene_census.csv")) ){
  
  cosmic_genes <- read.csv(
      file.path(utilsDir, "COSMIC_cancer_gene_census.csv")
    ) %>%
    dplyr::mutate(
      gene_name = hgnc_complete$symbol[match(
        Entrez.GeneId, stringr::str_extract(hgnc_complete$entrez_id, "[\\d]+")
      )],
      gene_name = ifelse(is.na(gene_name), Gene.Symbol, gene_name)
    ) %$%
    gene_name
    
}else{
  
  cosmic_genes <- vector(mode = "character")
  
}

genomic_features_path <- file.path(scriptDir, "GenomicHeatmapMaker")
epigenetic_features_path <- "/data/internal/epigeneticData/hg38" # Not archivable

epigenetic_features_files <- list.files(epigenetic_features_path) %>%
  grep("HeLa", ., invert = TRUE, value = TRUE) %>%
  grep("CD133", ., invert = TRUE, value = TRUE) %>%
  grep("HEK293T", ., invert = TRUE, value = TRUE) %>%
  grep("Jurkat", ., invert = TRUE, value = TRUE) %>%
  file.path(epigenetic_features_path, .)


## Develop standard factor scales for celltypes and timepoints ----
celltypeLevels <- c(
  "PB", "PBMC", "PBL", "Whole Blood", "Tcells", "Tcells:CAR+", 
  "Tcells:CAR+CD4+", "Tcells:CAR+CD8+", "Tcells:CAR+CD8-", "Tcells:CAR-CD4+", 
  "Tcells:CD4+SP", "Tcells:CAR-CD8+", "Tcells:CAR-CD8-", "Tcells:CD4+", 
  "Tcells:CD8+", "Tcells:CD8+Naive", "Tcells:CD8+Tscm", "Tcells:CD8+Tcm", 
  "Tcells:CD8+Tem", "Tcells:CD8+Te", "Tcells:CD8+Tm", "Tcells:CD4+CD8+", 
  "Tcells:CD4+CD8+DP", "Tcells:CD4+CD8+DN", "Bone Marrow", "BM", "BMMC", 
  "BM:CAR+", "CD3-"
)

timepointLevels <- c(
  "d-10", "d-1", "d0", "d1", "d5", "d7", "d9", "d10", "d11", "d13", "d14", 
  "d15", "d17", "d21", "d23", "d25", "d28", "d30", "d35", "d36", "d42", "d49",
  "d50", "m2", "d63", "d75", "d90", "m3", "d92", "d120", "d121", "m4", "d133",
  "d147", "m5", "d169", "m6", "d204", "m9", "m12", "y1", "d442", "m15", "m18", 
  "y1.5", "m20", "m21", "d720", "m24", "y2", "d801",  "y2.5", "m32", "y3", 
  "y4", "d1584", "y4.5", "m60", "y5", "y5.5", "y6", "y6.5", "y7", "y8"
)  

# Plot theme ----
custom_theme <- theme_bw() + 
  theme(
    panel.border = element_blank(), 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    strip.text = element_text(color = "black", face = "bold"),
    strip.background = element_rect(fill = "white", color = "white"),
    axis.line.x = element_line(color = "black"),
    axis.line.y = element_line(color = "black"),
    axis.title.y = element_text(color = "black", size = 10),
    axis.title.x = element_text(color = "black", size = 10),
    axis.text.x = element_text(color = "black", size = 10),
    axis.text.y = element_text(color = "black", size = 10),
    legend.text = element_text(color = "black", size = 10),
    legend.title = element_text(color = "black", size = 10),
    plot.title = element_text(color = "black", size = 12)
  )

# Load patient data ----
patient_data <- read.csv(
    file.path(outputDir, "cart19_intsite_sample_list.csv")
  ) %>%
  dplyr::distinct(Patient_ID, Disease, Response_to_Treatment) %>%
  dplyr::rename(
    "patient" = Patient_ID, 
    "disease" = Disease, 
    "response" = Response_to_Treatment
  ) %>%
  dplyr::mutate(
    clin_trial = str_extract(patient, "[0-9]+"),
    patient = gsub("_", "-", patient),
    disease = gsub("Adult ALL", "aALL", disease),
    disease = gsub("Pediatric ALL", "pALL", disease),
    disease = factor(disease, levels = c("pALL", "aALL", "CLL")),
    response = gsub(" but relapse", "\nw relapse", response),
    response = gsub(" - with transformed dz", "\nw TnDz", response),
    response = factor(
      response, 
      levels = c(
        "None", "Partial", "Partial\nw TnDz", 
        "Complete", "Complete\nw relapse")),
    simple_response = factor(
      str_extract(as.character(response), "[\\w]+"), 
      levels = c("None", "Partial", "Complete")),
    general_response = factor(ifelse(
      response == "None", "Non-responder", "Responder"), 
      levels = c("Non-responder", "Responder")),
    determinant_response = factor(ifelse(
      response %in% c("Complete", "Partial\nw TnDz", "Complete\nw relapse"), 
      "CR_PRtd", "PR_NR"), levels = c("CR_PRtd", "PR_NR"))
  ) %>%
  dplyr::arrange(disease, response)

patient_data[patient_data$patient == "p03712-12",]$response <- "None"
patient_data[patient_data$patient == "p03712-12",]$simple_response <- "None"
patient_data[patient_data$patient == "p03712-12",]$general_response <- "Non-responder"

std_clin_patients <- patient_data %>%
  dplyr::filter(clin_trial %in% std_clin_trials) %$%
  patient

CR_pats <- patient_data$patient[patient_data$determinant_response == "CR_PRtd"]
NR_pats <- patient_data$patient[patient_data$determinant_response == "PR_NR"]

## Load integration site analysis data ----
data_files <- list.files(outputDir)

### Load specimen_data
file <- grep("specimen_data", data_files, value = TRUE)
specimen_data <- readRDS(file.path(outputDir, file)) %>%
  dplyr::mutate(
    celltype = ifelse(
      as.character(celltype) == "PBMC", "PBL", as.character(celltype)),
    celltype = factor(celltype, levels = celltypeLevels)
  )

if( !all(patient_data$patient %in% specimen_data$patient) ){
  warning("Not all specimens in database, using custom data.")
  specimen_data <- dplyr::select(
      intsiteSpecimenMetadata, 
      Trial, Patient_ID, Abv_Cell_Type, 
      Sorting_Parameters, Timepoint, GTSP) %>%
    dplyr::rename(
      "trial" = Trial, "patient" = Patient_ID, 
      "timepoint" = Timepoint, "specimenaccnum" = GTSP) %>%       
    dplyr::mutate(
      celltype = ifelse(
        grepl("^s", Abv_Cell_Type),
        paste0(gsub("^s", "", Abv_Cell_Type), ":", Sorting_Parameters),
        Abv_Cell_Type),
      celltype = ifelse(
        as.character(celltype) == "PBMC", "PBL", as.character(celltype)),
      celltype = ifelse(
        as.character(celltype) == "Whole Blood", 
        "PBL", as.character(celltype)),
      celltype = factor(celltype, levels = celltypeLevels),
      timepoint = factor(timepoint, levels = timepointLevels)) %>%
    dplyr::select(trial, patient, celltype, timepoint, specimenaccnum) %>% 
    dplyr::arrange(specimenaccnum)
}


### Load condensed integrations sites
cond_uniq_sites <- readRDS(file.path(outputDir, "condensed_intsites.rds"))


### Load transduction product specific sites in a different format
tdn_sites <- readRDS(file.path(outputDir, "cart19_tdn_sites.rds"))
tdn_sites <- tdn_sites[tdn_sites$patient %in% std_clin_patients]
total_tdn_sites <- length(unique(paste(tdn_sites$patient, tdn_sites$posid)))

total_tdn_sites_CR <- length(unique(paste(
  tdn_sites$patient, tdn_sites$posid)[tdn_sites$patient %in% CR_pats]))

total_tdn_sites_NR <- length(unique(paste(
  tdn_sites$patient, tdn_sites$posid)[tdn_sites$patient %in% NR_pats]))

### Load timepoint or patient specific sites in a different format
timepoint_sites <- readRDS(
  file.path(outputDir, "cart19_timepoint_sites.rds")
)

timepoint_sites <- timepoint_sites[
  timepoint_sites$patient %in% std_clin_patients
]

total_pat_sites <- length(unique(paste(
  timepoint_sites$patient, timepoint_sites$posid
)))

total_pat_sites_CR <- length(unique(paste(
  timepoint_sites$patient, timepoint_sites$posid)[
    timepoint_sites$patient %in% CR_pats
  ]
))

total_pat_sites_NR <- length(unique(paste(
  timepoint_sites$patient, timepoint_sites$posid)[
    timepoint_sites$patient %in% NR_pats
  ]
))


### Load summaries: specimen, patient, timepoint, celltype 
summaries <- readRDS(
  file.path(outputDir, "cart19_summaries.rds")
)


### Load stats about transcription unit regions
gene_impact <- readRDS(
    file.path(outputDir, "cart19_gene_impact.rds")) %>%
  dplyr::select(
    -Within_Cluster, -Cluster_target.min, -ort_fisher_test, -ort_fisher_test_CR,
    -ort_fisher_test_NR) %>%
  dplyr::filter(!gene_name %in% excluded_gene_names) %>%
  dplyr::mutate(
    gene_name = alias_arbiter(
      IDs = gene_name,
      RefIDs = hgnc_complete$symbol,
      aliasIDs = hgnc_complete$extended_alias,
      sep = "|", remove_absent_IDs = NULL, quiet = TRUE
    )
  )

goi_data <- read.csv(
    file.path(outputDir, list.files(outputDir, pattern = "cart19_goi_data.csv"))
  ) %>%
  dplyr::mutate(Gene_Name = gsub("'", "", Gene_Name))

goi_lists <- lapply(
  c("Enrichment", "Depletion", "Abundance", "Longitudinal"), 
  function(x) goi_data$Gene_Name[goi_data[, x, drop = TRUE]] 
)

names(goi_lists) <- c(
  "Enrichment", "Depletion", "Abundance", "Longitudinal" #, "Cluster"
)

### Load the filtered unique integration sites as a reference
all_sites <- grep("filtered_unique_intsites", data_files, value = TRUE)
all_sites <- readRDS(file.path(outputDir, all_sites))
all_sites <- all_sites[all_sites$specimen %in% cond_uniq_sites$specimen]
all_sites <- all_sites[!generate_posid(all_sites) %in% excluded_sites]
all_sites <- all_sites[!generate_posid(all_sites) %in% potential_mispriming]

```

```{r kegg_pathways, include=FALSE}
# Import KEGG pathways ----
k_list <- keggList("hsa")
k_path <- keggList("pathway", "hsa")

k_pathList <- do.call(c, sapply(
  split(k_path, ceiling(seq_along(k_path)/100)),
  function(x) KEGGREST::keggLink("hsa", names(x))
))

k_pathList <- structure(
  hgnc_complete$symbol[match(k_pathList, hgnc_complete$kegg_id)],
  names = stringr::str_extract(names(k_pathList), "path:[\\w]+$")
)

k_pathList <- k_pathList[k_pathList %in% gene_impact$gene_name]
k_pathList <- split(k_pathList, names(k_pathList))
k_genes <- unique(unlist(k_pathList))

k_path_df <- plyr::ldply(
  k_pathList, 
  function(x){data.frame(gene_sym = x)}, 
  .id = "path"
)

```

```{r go_terms, include=FALSE}
# Import GO Biological Process reference ----
# Construct GO DAG from GO.db
Gobp <- unlist(as.list(GO.db::GOBPCHILDREN)) %>%
  data.frame(
    "vi" = str_extract(names(.), "[\\w:]+"),
    "vj" = .,
    "annotation" = str_extract(names(.), "[\\w]+$")) %>%
  dplyr::filter(!is.na(vj)) %>%
  dplyr::filter(annotation %in% c("is_a", "part_of")) %>%
  construct_graph(E = ., mode = "directed")

ignored_GOTERMs <- names(V(Gobp)[which(layout_as_tree(Gobp)[,2] >= 9)])

Gobp <- induced_subgraph(
  Gobp, names(V(Gobp))[!names(V(Gobp)) %in% ignored_GOTERMs]
)

# Pick up gene product annotations to GO terms (UniProt-GOA)
goa_bpdata <- load_go_gaf(
    paste0("zcat ", file.path(utilsDir, "goa_human.gaf.gz"))
  ) %>% 
  dplyr::mutate(gene_symbol = alias_arbiter(
    IDs = DB_Object_Symbol, 
    RefIDs = hgnc_complete$symbol, 
    aliasIDs = hgnc_complete$extended_alias, 
    sep = "|", remove_absent_IDs = NULL, quiet = TRUE)) %>%
  dplyr::filter(gene_symbol %in% gene_impact$gene_name) %>%
  dplyr::filter(GO_ID %in% V(Gobp)$name)

# Obtain specific (child) GO terms and general (ancestor) GO terms
buster <- makeCluster(numCores)

all_GOBP <- as.list(GO.db::GOBPOFFSPRING)

all_GOBP_list <- parLapply(
  buster, 
  seq_along(all_GOBP), 
  function(i, all_GOBP, goa_bpdata){
    terms <- c(names(all_GOBP[i]), all_GOBP[[i]])
    unique(goa_bpdata$gene_symbol[which(goa_bpdata$GO_ID %in% terms)])
  },
  all_GOBP = all_GOBP, 
  goa_bpdata = goa_bpdata
)

names(all_GOBP_list) <- names(all_GOBP)
all_GOBP_list <- all_GOBP_list[lengths(all_GOBP_list) > 0]
all_GOBP_list <- all_GOBP_list[names(all_GOBP_list) %in% names(V(Gobp))]

all_GOPB_df <- plyr::ldply(
  all_GOBP_list, function(x){data.frame(gene_sym = x)}, .id = "go_term"
)

stopCluster(buster)
go_genes <- unique(unlist(all_GOBP_list))
```

---

\newpage
## Figure 1. Experimental strategy and examples of results.
Figure 1. Experimental strategy and examples of results. (A) Diagram of the method for analyzing integration site distributions. Cells are harvested by apheresis, then transduced with the lentiviral vector encoding the CAR (top). Integration site distributions were quantified at several time points (middle; bottom). For this, DNA was isolated, then cleaved by sonication. DNA adaptors were ligated onto the free DNA ends, then PCR carried out using primers binding to the adaptor and the integrated vector DNA. PCR products were then sequenced and reads aligned to the human genome. The abundance of each transduced cell clone was inferred by the number of adaptor positions associated with each unique integration site (bottom; stacked bar graph). 

```{r fig1B, fig.width=7.5, fig.height=3.5}
vcn_summary <- within(
  list(), {
    
    ## Load data
    data_files <- list.files(outputDir)
    file_specimen <- grep("specimen_data", data_files, value = TRUE)
    file_vcn_data <- grep("vcn_data.rds", data_files, value = TRUE)
    specimen_data <- readRDS(file.path(outputDir, file_specimen))
    vcn_data <- readRDS(file.path(outputDir, file_vcn_data))
    
    ## Only work with PB and BM data, other samples are not 
    ## represented in intSites
    vcn_data <- dplyr::filter(vcn_data, type %in% c("PB", "BM")) %>%
      dplyr::mutate(celltype = factor(type, levels = c("PB", "BM"))) %>%
      dplyr::mutate(
        vcn = average.marking.cell,
        cpm = copies.microgram.dna)
    
    ## Identify inflection points that are present in the 
    ## integration sites datasets
    vcn_data$timepoint <- sapply(vcn_data$sample.timepoint, function(x){
      x <- tolower(x)
      if(grepl("day", x)){
        scale <- c("day", "d")
      }else if(grepl("month", x)){
        scale <- c("month", "m")
      }else if(grepl("year", x)){
        scale <- c("year", "y")
      }else{
        scale <- "Undetermined"
        timepoint <- "Undetermined"
      }
      
      if(!scale[1] == "Undetermined"){
        x <- unlist(strsplit(x, " "))
        scale_pos <- grep(scale[1], x)
        time <- as.numeric(x[(scale_pos + 1)])
        timepoint <- paste0(scale[2], time)
      }
      timepoint
    })
    
    specimen_coerce <- dplyr::select(
        specimen_data, patient, timepoint, celltype) %>% 
      dplyr::mutate(celltype = ifelse(
        as.character(celltype) %in% c("PBMC", "PBL", "PB"), 
        "PB", as.character(celltype))) %>%
      dplyr::mutate(timepoint = as.character(timepoint))
    
    vcn_coerce <- dplyr::select(vcn_data, patient, timepoint, celltype) %>%
      dplyr::mutate(celltype = as.character(celltype))
    
    vcn_intsite_intersect <- dplyr::intersect(specimen_coerce, vcn_coerce)
    
    vcn_data$intsite_matched <- with(
      vcn_data, paste(patient, celltype, timepoint)) %in% 
      with(vcn_intsite_intersect, paste(patient, celltype, timepoint))
    
    ## Generate faceted plots for each patient
    vcn_data <- dplyr::select(
        vcn_data, patient, celltype, timeline, vcn, cpm, intsite_matched) %>%
      dplyr::mutate(
        func.time = ifelse(timeline >= 0, timeline, -1.0),
        response = patient_data$determinant_response[
          match(patient, patient_data$patient)],
        resp = patient_data$response[
          match(patient, patient_data$patient)]) %>% 
      as.data.frame()
    
    peak_vcn_data <- vcn_data %>%
      left_join(patient_data, by = "patient") %>%
      dplyr::filter(
        disease == "CLL", func.time >= 10, func.time <= 21, celltype == "PB") %>%
      dplyr::rename("response" = determinant_response) %>%
      dplyr::group_by(patient, response) %>%
      dplyr::arrange(func.time) %>% 
      dplyr::summarise(
        m.cpm = max(cpm), max.func.time = func.time[match(m.cpm, cpm)]) %>% 
      dplyr::ungroup() %>%
      dplyr::mutate(log.m.cpm = log10(m.cpm)) %>%
      dplyr::arrange(m.cpm) %>%
      dplyr::filter(m.cpm >= 10)
    
    peak_vcn_means <- peak_vcn_data %>%
      dplyr::group_by(response) %>%
      dplyr::summarise(
        log.m.cpm = mean(log.m.cpm), 
        max.func.time = mean(max.func.time)) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(
        m.cpm = 10**log.m.cpm,
        min.time = 10, max.time = 21,
        celltype = "PB")
    
    peak_test <- wilcox.test(
        x = peak_vcn_data$m.cpm[peak_vcn_data$response == "CR_PRtd"], 
        y = peak_vcn_data$m.cpm[peak_vcn_data$response == "PR_NR"])$p.value %>%
      data.frame(
        celltype = "PB", 
        func.time = 180, cpm = 5,
        response = "PR_NR",
        text = paste0(
          "Difference during\npeak expansion\nP-value = ", round(., digits = 5)))
    
    pat_responses <- c("CR_PRtd" = "CR/PRtd", "PR_NR" = "PR/NR")
    
    vcn_data_by_pat <- split(vcn_data, vcn_data$patient)
    
    vcn_data_above <- dplyr::filter(
        vcn_data, cpm >= 10, func.time > 0, celltype == "PB")
    vcn_data_lod <- dplyr::filter(
        vcn_data, cpm < 10, func.time > 0, celltype == "PB") %>%
      dplyr::mutate(cpm = 10)
    
    time_res <- log10(5) + 
      (log10(365) - log10(5)) * seq_len(25)/25
    loess_span <- 0.65
    
    vcn_smooth <- bind_rows(lapply(seq_along(time_res), function(i){
        vcn_dat <- dplyr::filter(vcn_data, func.time >= 7, celltype == "PB")
        time_diff <- mean(unique(diff(time_res)))
        min_time <- max(log10(7), time_res[i] - time_diff)
        max_time <- min(log10(max(vcn_dat$func.time)), time_res[i] + time_diff)
        mid_time <- 10**mean(c(min_time, max_time))
        
        vcn_dat %>%
          dplyr::filter(func.time >= 7, celltype == "PB") %>%
          dplyr::filter(
            log10(func.time) >= min_time, log10(func.time) <= max_time
          ) %>%
          dplyr::group_by(patient, celltype, response, resp) %>%
          dplyr::mutate(cpm = ifelse(cpm < 10, log10(10), log10(cpm))) %>%
          dplyr::summarise(cpm.l = mean(cpm), func.time = mid_time) %>%
          dplyr::group_by(celltype, response, func.time) %>%
          dplyr::summarise(
            cpm.m = sort(cpm.l)[qbinom(p = 0.5, size = n(), prob = 0.5)],
            cpm.lo = sort(cpm.l)[
              max(1, qbinom(p = 0.025, size = n(), prob = 0.5))],
            cpm.hi = sort(cpm.l)[
              min(n(), qbinom(p = 0.975, size = n(), prob = 0.5))],
            pats = n()) %>%
          dplyr::ungroup() %>%
          dplyr::mutate(func.time.l = log10(func.time))
        
        })) %>% 
      dplyr::filter(pats >= 3) %>%
      dplyr::group_by(celltype, response) %>%
      dplyr::mutate(
        cpm.m.sm = predict(
          loess(cpm.m ~ func.time.l, span = 0.65, degree = 2),
          data.frame(func.time.l = func.time.l)),
        cpm.lo.sm = predict(
          loess(cpm.lo ~ func.time.l, span = 0.65, degree = 2),
          data.frame(func.time.l = func.time.l)),
        cpm.hi.sm = predict(
          loess(cpm.hi ~ func.time.l, span = 0.65, degree = 2),
          data.frame(func.time.l = func.time.l))) %>%
      dplyr::ungroup()
    
    vcn_plot <- ggplot() +
      geom_text(
        data = peak_test, 
        aes(x = log10(func.time), y = cpm, label = text)) +
      geom_ribbon(
        data = vcn_smooth, 
        aes(x = func.time.l, ymin = cpm.lo.sm, ymax = cpm.hi.sm), 
        fill = "grey85") +
      geom_line(
        data = vcn_smooth,
        aes(x = func.time.l, y = cpm.m.sm), 
        color = "black", size = 2.0) +
      geom_point(
        data = bind_rows(vcn_data_above, vcn_data_lod),
        aes(x = log10(func.time), y = log10(cpm)), 
        color = "grey50", size = 1.5) +
      geom_hline(
        yintercept = log10(10), linetype = "dotted", 
        color = "grey50", size = 0.5) +
      facet_grid(
        . ~ response, scales = "free", 
        labeller = labeller(response = pat_responses)) +
      scale_color_brewer(palette = "Set1") +
      scale_fill_brewer(palette = "Set1") +
      scale_x_continuous(
        limits = log10(c(6, 365)),
        breaks = log10(c(7, 14, 30, 60, 120, 365)), 
        labels = c("1w", "2w", "1m", "2m", "4m", "1y")) +
      scale_y_continuous(
        limits = c(0.9, 5.65),
        breaks = seq(1, 5, 1), 
        labels = c("LOD", seq(2, 5, 1))) + 
      coord_cartesian(xlim = log10(c(5, 365))) +
      theme_bw() + 
      custom_theme +
      theme(legend.position = "none") +
      labs(
        x = "Treatment time",
        y = "Vector copies per microgram of DNA (Log)")
      
    vcn_plots_by_pat <- lapply(vcn_data_by_pat, function(data){
      p <- ggplot(data, aes(func.time, log10(cpm), color = celltype)) +
        geom_line() +
        scale_y_continuous(        
          breaks = seq(1, 5, 1), 
          labels = c("LOD", seq(2, 5, 1))) + 
        theme_bw() +
        labs(
          title = unique(data$patient), 
          x = "Treatment time (d)", 
          y = "Vector copies per microgram of DNA (Log)",
          color = "CellType")
      
      if(nrow(data[data$intsite_matched,]) > 0){
        p <- p + 
          geom_point(
            data = data[data$intsite_matched == TRUE,], 
            aes(func.time, log10(cpm), fill = celltype), 
            shape = 21, size = 4, color = "white") + 
          labs(fill = "IntSite\nMatched")
      }
      p
    })
  }
)

vcn_summary$vcn_plot
```
Figure 1. (B) Vector copy number (VCN) analyzed by QPCR longitudinally, comparing CR/PRtd to PR/NR. Peak expansion was assessed as maximal VCN 10 to 21 days post-infusion. The difference in medians was tested using the Wilcoxon Rank-sum test. 

\newpage
```{r specimen_barplots}
intsite_barplots <- within(
  list(), {

    # Barplot data generation
    cond_sites <- cond_uniq_sites
    barplot_sites_list <- split(cond_sites, cond_sites$patient)
    num_top_genes <- 100
    
    barplot_list <- lapply(barplot_sites_list, function(sites, num_top_genes){
      
      sites <- sites[order(sites$relAbund, decreasing = TRUE),]
      most_abund_pos_ids <- head(unique(sites$posid), n = num_top_genes)
      
      cutoff <- sites$estAbund[
        match(tail(most_abund_pos_ids, n = 1), sites$posid)]
      
      barplot.df <- data.frame(
        "specimen" = sites$specimen,
        "patient" = sites$patient,
        "timepoint" = factor(sites$timepoint, levels = timepointLevels),
        "celltype" = factor(sites$celltype, levels = celltypeLevels),
        "posid" = sites$posid,
        "gene_id" = sites$gene_id,
        "abund" = sites$estAbund,
        "relabund" = sites$relAbund,
        stringsAsFactors = FALSE
      )
      
      barplot.df$bp_id <- ifelse(
        barplot.df$posid %in% most_abund_pos_ids, 
        barplot.df$gene_id, 
        "LowAbund")
      
      bp_lookup_tbl <- dplyr::distinct(barplot.df, posid, bp_id) %>%
        dplyr::group_by(bp_id) %>%
        dplyr::mutate(bp_id2 = ifelse(
          n() <= 1 | bp_id == "LowAbund",
          bp_id,
          paste0(bp_id, "(", seq_len(n()), ")"))) %>%
        dplyr::ungroup()
      
      barplot.df$bp_id <- bp_lookup_tbl$bp_id2[
        match(barplot.df$posid, bp_lookup_tbl$posid)]

      barplot.df <- dplyr::group_by(barplot.df, specimen) %>%
        dplyr::mutate(specimen_sites = n_distinct(posid)) %>%
        dplyr::mutate(inferred_cells = sum(abund)) %>%
        dplyr::ungroup(.) %>%
        dplyr::mutate(site_bp_id = ifelse(
          bp_id == "LowAbund", "LowAbund", paste0(posid, "^", gene_id))) %>%
        dplyr::group_by(specimen, site_bp_id) %>%
        dplyr::mutate(bp_abund = sum(abund)) %>%
        dplyr::mutate(bp_relabund = sum(relabund)) %>%
        dplyr::ungroup() %>%
        dplyr::group_by(bp_id) %>%
        dplyr::mutate(bp_id2 = ifelse(
          n_distinct(site_bp_id) > 1, 
          paste0(bp_id, "(", match(site_bp_id, unique(site_bp_id)), ")"),
          bp_id)) %>%
        dplyr::ungroup() %>%
        dplyr::mutate(bp_id = bp_id2) %>%
        dplyr::select(-abund, -relabund, -gene_id, -posid, -site_bp_id, -bp_id2) %>%
        dplyr::mutate(bp_id = factor(bp_id)) %>%
        dplyr::distinct(.)
      
      colors_bp <- colorRampPalette(
        brewer.pal(n = 8, name = "Dark2"))(length(levels(barplot.df$bp_id)))  #Color Palette
      bpColors <- structure(colors_bp, names = levels(barplot.df$bp_id))
      bpColors["LowAbund"] <- "#E0E0E0"
      barplot.df$bp_colors <- bpColors[barplot.df$bp_id]
      list(barplot.df, cutoff)
      
      },
      num_top_genes = num_top_genes
    )
    
    barplots <- lapply(barplot_list, function(list){
      
      cutoff <- list[[2]]
      data <- list[[1]]
      
      data <- dplyr::arrange(data, desc(bp_abund)) %>%
        dplyr::mutate(
          celltype = gsub("PBMC", "PBL", celltype),
          celltype = gsub("Whole Blood", "PBL", celltype),
          celltype = gsub("Bone Marrow", "BM", celltype),
          celltype = factor(celltype, levels = celltypeLevels),
          celltype = fct_relevel(fct_drop(celltype), "Tcells"),
          bp_id = fct_relevel(fct_drop(bp_id), unique(as.character(bp_id))),
          timepoint = fct_drop(timepoint)) %>%
        dplyr::arrange(bp_id) %>%
        dplyr::mutate(
          bp_id = fct_relevel(bp_id, sort(as.character(levels(bp_id)))),
          bp_id = fct_relevel(bp_id, "LowAbund"))

      data <- bind_rows(
        dplyr::filter(data, bp_id != "LowAbund"),
        dplyr::filter(data, bp_id == "LowAbund")
      )

      gtsp_order <- dplyr::arrange(data, timepoint, celltype) %>%
        dplyr::distinct(
          specimen, celltype, timepoint, specimen_sites, inferred_cells) %>%
        dplyr::mutate(
          celltype = gsub("PBMC", "PBL", celltype),
          celltype = factor(celltype, levels = celltypeLevels),
          label = paste0(celltype, "\n", inferred_cells),
          specimen = factor(
            as.character(specimen), levels = unique(as.character(specimen))))

      data$specimen <- factor(
        data$specimen, levels = levels(gtsp_order$specimen))

      patient <- unique(data$patient)

      specimen_label <- function(x){
        as.character(gtsp_order[match(x, gtsp_order$specimen), "label"])}

      ggplot() +
        geom_bar(
          data = data, aes(specimen, bp_relabund, fill = bp_id), 
          stat = "identity") +
        geom_text(
          data = gtsp_order, 
          aes(x = specimen, y = rep(1.12, nrow(gtsp_order)), label = celltype), 
          size = 4) +
        geom_text(
          data = gtsp_order, 
          aes(x = specimen, y = rep(1.08, nrow(gtsp_order)), label = inferred_cells), 
          size = 4) +
        geom_text(
          data = gtsp_order, 
          aes(x = specimen, y = rep(1.04, nrow(gtsp_order)), label = specimen_sites), 
          size = 4) +
        facet_grid(. ~ celltype, scales = "free", space = "free") +
        scale_fill_manual(values = data[
          match(levels(data$bp_id), as.character(data$bp_id)),]$bp_colors) +
         scale_x_discrete(breaks = gtsp_order$specimen, labels = gtsp_order$timepoint) +
        labs(y = "Relative Abundance", x = "Timepoint", fill = "GeneNames",
          title = paste0(patient, " Rel. Abund. Barplot (cutoff = ", cutoff, " cells)")) +
        scale_y_continuous(
          breaks = c(0, 0.25, 0.5, 0.75, 1.0), 
          labels = scales::percent) +
        guides(fill = guide_legend(
            reverse = FALSE, ncol = 7,
            label.theme = element_text(angle = 0, color = "black", size = 10),
            title.theme = element_text(angle = 0, color = "black", size = 10))) +
        theme(
          axis.text.x = element_text(
            angle = 45, hjust = 1, vjust = 1, color = "black", size = 12),
          axis.text.y = element_text(color = "black", size = 12),
          axis.title.x = element_text(color = "black", size = 12),
          axis.title.y = element_text(color = "black", size = 12),
          panel.background = element_rect(fill = "white"),
          panel.border = element_rect(colour = "black", fill = NA, size = 0.5),
            legend.position = "bottom") #+
        #annotate("text", x = rep(0.63, 3), y = c(1.12, 1.08, 1.04),
        #         label = c("CellType:", "Cells:", "Sites:"), size = 4)
    })
  }
)
```

```{r fig1C, fig.width=5, fig.height=5}
response_barplot <- within(
  list(), {

    pats_list <- c("p04409-09", "p04409-22", "p04409-12", "p04409-18")
    resp_list <- structure(
      c("CR", "PRtd", "PR", "NR"),
      names = pats_list)
    resp_list <- factor(resp_list, levels = unique(resp_list))
    initial_data <- intsite_barplots$barplot_list[pats_list]
    curated_data <- bind_rows(lapply(initial_data, function(x){
      data <- x[[1]] %>%
        dplyr::arrange(desc(bp_abund)) %>%
        dplyr::mutate(
          celltype = gsub("PBMC", "PBL", celltype),
          celltype = gsub("Whole Blood", "PBL", celltype),
          celltype = gsub("Bone Marrow", "BM", celltype)) %>%
        dplyr::filter(celltype %in% c("Tcells", "PBL")) %>%
        dplyr::filter(as.integer(timepoint) %in% c(3, 17, 24, 35, 39, 40)) %>%
        dplyr::mutate(cutoff = x[[2]]) %>%
        dplyr::arrange(bp_id)

      bind_rows(
        dplyr::filter(data, bp_id != "LowAbund"),
        dplyr::filter(data, bp_id == "LowAbund"))
      })) %>%
      dplyr::mutate(
        resp = resp_list[patient],
        bp_id = factor(bp_id, sort(unique(bp_id))),
        bp_id = fct_relevel(bp_id, "LowAbund"),
        timepoint = fct_drop(timepoint),
        celltype = factor(celltype, levels = celltypeLevels),
        celltype = fct_drop(celltype),
        celltype = fct_relevel(celltype, "Tcells"))

    gtsp_order <- dplyr::arrange(curated_data, timepoint, celltype) %>%
      dplyr::distinct(
        specimen, patient, celltype, 
        timepoint, specimen_sites, inferred_cells) %>%
      dplyr::mutate(
        resp = resp_list[patient],
        patient = factor(patient, pats_list),
        celltype = gsub("PBMC", "PBL", celltype),
        celltype = factor(celltype, levels = levels(curated_data$celltype)),
        label = paste0(celltype, "\n", inferred_cells),
        specimen = factor(
          as.character(specimen), levels = unique(as.character(specimen))))
      
    curated_data$specimen <- factor(curated_data$specimen, gtsp_order$specimen)
    curated_data$patient <- factor(curated_data$patient, pats_list)
    
    specimen_label <- function(x){
      as.character(gtsp_order[match(x, gtsp_order$specimen), "label"])}
    
    barplot <- ggplot() +
      geom_bar(
        data = curated_data, 
        aes(x = timepoint, y = bp_relabund, fill = bp_id), 
        stat = "identity") +
      facet_grid(
        patient + resp ~ celltype, 
        scales = "free", space = "free") +
      scale_fill_manual(values = curated_data$bp_colors[match(
        levels(curated_data$bp_id), 
        as.character(curated_data$bp_id))]) +
      labs(y = "% Relative Abundance", x = "Timepoint", fill = NULL) +
      scale_y_continuous(
        breaks = c(0, 0.25, 0.5, 0.75, 1.0), labels = seq(0, 100, 25)) +
      custom_theme +
      theme(
        axis.text.x = element_text(angle = 0, hjust = 0.5, vjust = 1),
        legend.position = "none",
        strip.text.y = element_text(
          angle = 0, face = "plain", size = 11, hjust = 0
        ),
        strip.text.x = element_text(face = "plain", size = 10),
        panel.background = element_rect(color = "black"))
    
  }
)
response_barplot$barplot
```
Figure 1. (C) Examples of longitudinal analysis of integration site distributions for CR, PRtd, PR and NR subjects. “Day 0” indicates the pre-infusion T-cell product. Later samples from patients were from peripherial blood (PBL). Each color indicates a different clone; the height of the bar indicates the relative abundance. No clones were shared between patients. Light grey indicates low abundance clones. The abundant clone in the CR subject (red) is in the gene ZNF573.

\newpage
## Figure 2. Clonal expansion of CART19 cells assessed by tracking sites of integrated vectors.
```{r clonal_skewing_across_patients}
intsite_clone_skew_plots <- within(
  list(), {

    # Generate plots of site abundance distributions
    cutoff <- 1 # percent
    
    tp_high_abund_posids <- get_top_sites(timepoint_sites, cutoff, "estAbund")
    timepoint_sites$abund_status <- ifelse(
      timepoint_sites$posid %in% tp_high_abund_posids,
      "High Abundance", "Low Abundance")
    
    abund_cutoff <- timepoint_sites %>% 
      as.data.frame(row.names = NULL) %>% 
      dplyr::filter(abund_status == "High Abundance") %>% 
      dplyr::group_by(posid) %>% 
      top_n(1, estAbund) %>% 
      dplyr::ungroup() %$% 
      min(estAbund)
    
    ## Now for TDN specimens
    tdn_sites$abund_status <- ifelse(
      tdn_sites$estAbund >= abund_cutoff, "High Abundance", "Low Abundance")

    tdn_high_sites <- tdn_sites[tdn_sites$abund_status == "High Abundance"]
    tdn_low_sites <- tdn_sites[tdn_sites$abund_status == "Low Abundance"]

    tdn_df <- as.data.frame(tdn_sites, row.names = NULL)
    
    tdn_df <- tdn_df[order(tdn_df$estAbund, decreasing = TRUE),] %>% 
      dplyr::filter(!duplicated(posid))
    
    compressed_tdn_df <- tdn_df %>%
      dplyr::mutate(rank_ord = seq_len(n())) %>%
      dplyr::group_by(abund_status, estAbund) %>%
      dplyr::summarise(start = min(rank_ord), end = max(rank_ord)) %>%
      dplyr::ungroup() %>%
      dplyr::arrange(start)
    
    tdn_high_and_low_abund_plot <- ggplot() +
      geom_segment(
        data = compressed_tdn_df,
        aes(
          x = start, xend = end, 
          y = estAbund, yend = estAbund, 
          color = factor(abund_status)
        ),
        size = 2.5, lineend = "round"
      ) +
      scale_x_continuous(labels = comma) +
      scale_y_continuous(
        breaks = c(1, 10, 100, 1000), labels = c("1", "10", "100", "1,000"), 
        trans = "log10", limits = c(1, 1000)) +
      scale_color_brewer(type = "qual", palette = "Set1") +
      labs(
        title = "A. TDN Products",
        x = "Ordered integration sites",
        y = "Sonic abundance",
        color = ""
      ) +
      theme_bw() +
      theme(
        legend.position = "none",
        panel.border = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),
        title = element_text(color = "black", size = 8, face = "plain"),
        axis.text.x = element_text(size = 7),
        axis.title = element_text(size = 8, color = "black", face = "plain")
      )

    ## Day 28 only
    d28_sites <- timepoint_sites[timepoint_sites$timepoint == "d28"]
    d28_sites$abund_status <- ifelse(d28_sites$estAbund >= abund_cutoff,
                                     "High Abundance", "Low Abundance")
    d28_sites$determinant_response <- patient_data$determinant_response[
      match(d28_sites$patient, patient_data$patient)]
    
    d28_high_sites <- d28_sites[d28_sites$abund_status == "High Abundance"]
    d28_low_sites <- d28_sites[d28_sites$abund_status == "Low Abundance"]
    
    d28_df <- as.data.frame(d28_sites, row.names = NULL)
    d28_df <- d28_df[order(d28_df$estAbund, decreasing = TRUE),] %>% 
      dplyr::filter(!duplicated(posid))
    
    d28_CR_PRtd <- d28_df %>%
      dplyr::filter(determinant_response == "CR_PRtd")
    
    compressed_d28_CR_PRtd <- d28_CR_PRtd %>%
      dplyr::mutate(rank_ord = seq_len(n())) %>%
      dplyr::group_by(abund_status, estAbund) %>%
      dplyr::summarise(start = min(rank_ord), end = max(rank_ord)) %>%
      dplyr::ungroup() %>%
      dplyr::arrange(start)
    
    d28_PR_NR <- d28_df %>%
      dplyr::filter(determinant_response == "PR_NR")
    
    compressed_d28_PR_NR <- d28_PR_NR %>%
      dplyr::mutate(rank_ord = seq_len(n())) %>%
      dplyr::group_by(abund_status, estAbund) %>%
      dplyr::summarise(start = min(rank_ord), end = max(rank_ord)) %>%
      dplyr::ungroup() %>%
      dplyr::arrange(start)
    
    d28_CR_PRtd_abund_plot <- ggplot() +
      geom_segment(
        data = compressed_d28_CR_PRtd,
        aes(
          x = start, xend = end, 
          y = estAbund, yend = estAbund, 
          color = factor(abund_status)
        ),
        size = 2.5, lineend = "round"
      ) +
      geom_text_repel(
        data = d28_CR_PRtd[1:10,], 
        aes(x = 1:10, y = estAbund, label = gene_id_wo_annot),
        segment.alpha = 0.5, size = 3, nudge_x = 2000
      ) +
      scale_x_continuous(labels = comma) +
      scale_y_continuous(
        breaks = c(1, 10, 100, 1000), labels = c("1", "10", "100", "1,000"), 
        trans = "log10", limits = c(1, 1000)
      ) +
      scale_color_brewer(type = "qual", palette = "Set1") +
      labs(
        title = "B. CR/PRtd - Day 28",
        x = "Ordered integration sites",
        y = " ",
        color = ""
      ) +
      theme_bw() +
      theme(
        legend.position = "none",
        panel.border = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),
        title = element_text(color = "black", size = 8, face = "plain"),
        axis.text.x = element_text(size = 7),
        axis.title = element_text(size = 8, color = "black", face = "plain")
      )


    d28_PR_NR_abund_plot <- ggplot() +
      geom_segment(
        data = compressed_d28_PR_NR,
        aes(
          x = start, xend = end, 
          y = estAbund, yend = estAbund, 
          color = factor(abund_status)
        ),
        size = 2.5, lineend = "round"
      ) +
      scale_x_continuous(labels = comma) +
      scale_y_continuous(
        breaks = c(1, 10, 100, 1000), labels = c("1", "10", "100", "1,000"), 
        trans = "log10", limits = c(1, 1000)
      ) +
      scale_color_brewer(type = "qual", palette = "Set1") +
      labs(
        title = "C. PR/NR - Day 28",
        x = "Ordered integration sites",
        y = " ",
        color = ""
      ) +
      theme_bw() +
      theme(
        legend.position = "none",
        panel.border = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),
        title = element_text(color = "black", size = 8, face = "plain"),
        axis.text.x = element_text(size = 7),
        axis.title = element_text(size = 8, color = "black", face = "plain")
      )

        
    ## Responders to non-responders
    mod_gene_impact <- gene_impact %>%
      dplyr::filter(TP_num_sites > 0) %>% 
      dplyr::mutate(
        TP_peak_abund_CR = ifelse(
          TP_peak_abund_CR == 0, 0.5, TP_peak_abund_CR),
        TP_peak_abund_NR = ifelse(
          TP_peak_abund_NR == 0, 0.5, TP_peak_abund_NR),
        TP_sum_abund_CR = ifelse(
          TP_sum_abund_CR == 0, 0.5, TP_sum_abund_CR),
        TP_sum_abund_NR = ifelse(
          TP_sum_abund_NR == 0, 0.5, TP_sum_abund_NR))
    
    peak_abund_bivar <- ggplot() +
      geom_abline(slope = 1, intercept = 0, color = "grey50") +
      geom_count(
        data = mod_gene_impact, 
        aes(x = TP_peak_abund_NR, y = TP_peak_abund_CR, color = abund_gini)) +
      scale_y_log10(
        breaks = c(0.5, 1, 10, 100, 1000), 
        labels = c("0", "1", "10", "100", "1,000")) + 
      scale_x_log10(
        breaks = c(0.5, 1, 10, 50), labels = c("0", "1", "10", "50")) +
      scale_size_continuous(trans = "log10") +
      coord_cartesian(ylim = c(0.5, 1500)) +
      geom_text_repel(
        data = dplyr::filter(
          mod_gene_impact, TP_peak_abund_CR >= 120 | TP_peak_abund_NR >= 15), 
        aes(x = TP_peak_abund_NR, y = TP_peak_abund_CR, label = gene_name),
        segment.alpha = 0.5, size = 2, nudge_x = 0.2, nudge_y = 0.25) +
      labs(
        x = "Peak Clonal Abundance\nfor PR/NR Patients",
        y = "Peak Clonal Abundance\nfor CR/PRtd Patients",
        color = "Abund.\nGini", size = "Gene\nCount") +
      custom_theme
      
    sum_abund_bivar <- ggplot() +
      geom_abline(slope = 1, intercept = 0, color = "grey50") +
      geom_count(
        data = mod_gene_impact, 
        aes(x = TP_sum_abund_NR, y = TP_sum_abund_CR, color = abund_gini)) +
      scale_y_log10(
        breaks = c(0.5, 1, 10, 100, 1000), 
        labels = c("0", "1", "10", "100", "1,000")) + 
      scale_x_log10(
        breaks = c(0.5, 1, 10, 50), labels = c("0", "1", "10", "100")) +
      scale_size_continuous(trans = "log10") +
      coord_cartesian(ylim = c(0.5, 2000)) +
      geom_text_repel(
        data = dplyr::filter(
          mod_gene_impact, TP_sum_abund_CR >= 200 | TP_sum_abund_NR >= 25), 
        aes(x = TP_sum_abund_NR, y = TP_sum_abund_CR, label = gene_name),
        segment.alpha = 0.5, size = 2, nudge_x = 0.2, nudge_y = 0.25) +
      labs(
        x = "Cumulative Clonal Abundance\nfor PR/NR Patients",
        y = "Cumulative Clonal Abundance\nfor CR/PRtd Patients",
        color = "Abund.\nGini", size = "Gene\nCount") +
      custom_theme
    
    
  }
)
``` 

```{r longitudinal_clone_plots}
#Written to file: /path/to/CART19_intsite_manuscript_analysis/reports/manuscript_figures/

long_clone_plots <- within(
  list(), {
    # Summarise each clones behavior
    clone_data <- as.data.frame(cond_uniq_sites, row.names = NULL) %>%
      dplyr::filter(patient %in% std_clin_patients) %>%
      dplyr::select(
        patient, timepoint, celltype, specimen, 
        estAbund, relAbund, posid, gene_id
      ) %>%
      dplyr::mutate(dtime = convert_time(as.character(timepoint))) %>%
      dplyr::group_by(patient, posid, gene_id) %>%
      dplyr::summarise(
        tfs = paste(sort(unique(as.integer(timepoint))), collapse = ","),
        min_tf = min(as.integer(timepoint)), 
        max_tf = max(as.integer(timepoint)),
        tps = paste(sort(unique(dtime)), collapse = ","),
        min_tp = min(dtime), max_tp = max(dtime),
        num_tp = n_distinct(timepoint),
        num_ct = n_distinct(celltype), num_sp = n_distinct(specimen),
        min_ab = min(estAbund), max_ab = max(estAbund),
        min_rb = min(relAbund), max_rb = max(relAbund)
      ) %>%
      dplyr::arrange(desc(num_tp), desc(max_ab), desc(min_ab)) %>%
      dplyr::ungroup()
    
    # Isolate data for plot
    plot_clones <- clone_data %>%
      dplyr::group_by(patient) %>%
      dplyr::arrange(desc(max_tp - min_tp), desc(max_rb)) %>%
      dplyr::slice(1:10) %$%
      unique(paste0(patient, ":", posid))

    plot_data <- as.data.frame(cond_uniq_sites, row.names = NULL) %>%
      dplyr::select(patient, timepoint, posid, gene_id, estAbund, relAbund) %>%
      dplyr::filter(paste0(patient, ":", posid) %in% plot_clones) %>%
      dplyr::mutate(
        tp = convert_time(as.character(timepoint)),
        tp = ifelse(tp == 0, 7.5, tp),
        tp = ifelse(tp == 1, 8.5, tp),
        pf = as.integer(
          factor(paste0(patient, ":", posid), levels = rev(plot_clones)))
      ) %>%
      dplyr::group_by(patient, timepoint, tp, pf, posid, gene_id) %>%
      dplyr::summarise(
        logAbund = log(mean(estAbund), base = 10),
        estAbund = mean(estAbund),
        relAbund = mean(relAbund)
      ) %>%
      dplyr::group_by(patient, posid, gene_id) %>%
      dplyr::mutate(num_tp = n_distinct(tp)) %>%
      dplyr::ungroup() %>%
      dplyr::group_by(num_tp) %>%
      dplyr::mutate(pf = as.integer(factor(pf, levels = sort(unique(pf))))) %>%
      dplyr::ungroup()

    # Formated for 7"w by 3"h
    split_plot_data <- split(plot_data, plot_data$patient)
     
    long_plots <- lapply(split_plot_data, function(df){
      
      df <- df %>%
        dplyr::arrange(desc(estAbund)) %>%
        dplyr::mutate(
          patient = paste0("Patient: ", patient),
          plot_id = paste0(gene_id, "\n", posid),
          plot_id = factor(plot_id, levels = unique(plot_id))
        )
      
      axis_breaks <- c(
        7.5, 10, 14, 28, 60, 90, 120, 240, 365, 730, 1095, 1826
      )
      
      axis_labels <- c(
        "TDN", "d10", "d14", "d28", "m2", "m3", "m4", "m8", 
        "y1", "y2", "y3", "y5"
      )
      
      max_tp <- max(df$tp)
      max_idx <- min(which(axis_breaks > max_tp))
      max_idx <- max(c(max_idx, 5))
      
      axis_breaks <- axis_breaks[seq_len(max_idx)]
      axis_labels <- axis_labels[seq_len(max_idx)]
      
      ggplot(df, aes(x = tp, y = relAbund)) +
        geom_line(aes(group = plot_id), alpha = 0.15) +
        geom_point(aes(color = plot_id), size = 2.5) +
        facet_grid(. ~ patient) +
        scale_color_brewer(type = "seq", palette = "Paired") +
        scale_x_log10(
          breaks = axis_breaks,
          labels = axis_labels,
          limits = c(7.5, max(df$tp))
        ) + 
        labs(
          x = "Treatment Time", 
          y = "Relative Abundance", 
          color = NULL
        ) +
        guides(
          color = guide_legend(
            direction = "vertical",
            keyheight = unit(0.27, units = "in"))
        ) +
        custom_theme +
        theme(
          legend.position = "right",
          legend.text = element_text(size = 7.5),
          axis.line.y = element_line(color = "black"),
          axis.line.x = element_line(color = "black"),
          axis.text.x = element_text(size = 9),
          strip.text.y = element_text(angle = 0)
        )
      
    })
    
    # null <- lapply(seq_along(long_plots), function(i){
    #   
    #   file_pdf <- paste0("supfig.", names(long_plots)[i], ".long_plot.pdf")
    #   
    #   ggsave(
    #     filename = file_pdf, 
    #     plot = long_plots[[i]], 
    #     device = "pdf", 
    #     path = file.path(workingDir, "reports/manuscript_figures"), 
    #     width = 7, 
    #     height = 3, 
    #     units = "in"
    #   )
    #   
    # })
    
})
```

```{r fig2ABC, fig.width=7, fig.height=3}
grid.arrange(
  grobs = list(
    intsite_clone_skew_plots$tdn_high_and_low_abund_plot,
    intsite_clone_skew_plots$d28_CR_PRtd_abund_plot,
    intsite_clone_skew_plots$d28_PR_NR_abund_plot), 
  nrow = 1)
```
Figure 2. Clonal behavior of CART19 cells assessed by tracking sites of integrated vectors. A-C) Rank-abundance plots summarizing clonal abundance for the (transduction–TDN) products (A); CR/PRtd assayed at Day 28 (B); and PR/NR assayed at Day 28 (C). Cell clones (identified by identical integration sites) were ordered by most abundant (left) to least abundant (right) as assessed by SonicAbundance. Highly abundant clones (red) were scored as the top 1% of all expanded clones, corresponding to at least 9 cells representing each clone. The top 10 most abundant clones for CR/PRtd at day 28 are labeled with gene symbols. A Venn diagram showing overlap among the top 30 most expanded clones in A-C is in Fig. S2. 

```{r fig2D, fig.width=3.5, fig.height=5}
gene_freq_bivar <- within(
  list(), {

    freq_bivar <- dplyr::filter(
        gene_impact, 
        TP_num_patients >= 2,
        TP_num_sites >= 10) %>%
      dplyr::arrange(desc(pct_chg)) %>%
      dplyr::mutate(id = 1:n()) %>%
      dplyr::group_by(id) %>%
      dplyr::mutate(freq_fisher_test = fisher.test(
        matrix(
          c(TDN_num_sites, TP_num_sites, 
            total_tdn_sites - TDN_num_sites, total_pat_sites - TP_num_sites), 
          ncol = 2))$p.value) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(adj_freq_test = p.adjust(freq_fisher_test, method = "BH"))
      
    key_enrich_freq_genes <- dplyr::filter(
        freq_bivar, adj_freq_test <= 0.05, pct_chg > 0
      ) %>%
      dplyr::arrange(adj_freq_test) %>%
      head(n = 10)

    key_deplet_freq_genes <- dplyr::filter(
        freq_bivar, adj_freq_test <= 0.05, pct_chg < 0
      ) %>%
      dplyr::arrange(adj_freq_test) %>%
      head(n = 10)

    vdata <- freq_bivar %>%
      dplyr::mutate(
        grp = ifelse(
          pct_chg <= -10, "low", ifelse(pct_chg >= 10, "high", "mid")
        ),
        adj_chg = ifelse(
          grp == "low", 
          -log(abs(pct_chg), base = 10),
          ifelse(grp == "high", log(pct_chg, base = 10), 0)
        ),
        adj_freq_scale = log(1 / freq_fisher_test)
      ) %>%
      dplyr::filter(
        grp != "mid",
        freq_fisher_test < 1
      ) %>%
      dplyr::mutate(grp = factor(grp, levels = c("low", "mid", "high")))
    
    vol_plot <- ggplot() +
      geom_point(
        data = vdata, 
        aes(x = adj_chg, y = adj_freq_scale), 
        shape = 21, color = "black", fill = "white"
      ) +
      geom_hline(
        yintercept = log(1/0.05, base = 10), 
        linetype = "dotted", color = "black"
      ) +
      geom_text_repel(
        data = dplyr::filter(vdata, loci %in% key_enrich_freq_genes$loci),
        aes(x = adj_chg, y = adj_freq_scale, label = gene_name),
        nudge_x = -0.1, nudge_y = 2, segment.alpha = 0.25,
        box.padding = unit(0.3, "lines"), size = 3
      ) +
      geom_text_repel(
        data = dplyr::filter(vdata, loci %in% key_deplet_freq_genes$loci),
        aes(x = adj_chg, y = adj_freq_scale, label = gene_name),
        nudge_x = 0.1, nudge_y = 1, segment.alpha = 0.25,
        box.padding = unit(0.3, "lines"), size = 3
      ) +
      facet_grid(. ~ grp, scales = "free") +
      scale_color_continuous(high = "#132B43", low = "#56B1F7") +
      scale_x_continuous(
        breaks = c(-2, -log10(50), -1, 0, 1, log10(50), 2), 
        labels = c("-100", "-50", "-10", "0", "10", "50", "100")
      ) +
      labs(
        x = "Change in Integration Freq. (%)", 
        y = "Enrichment (Log inverse p-value)"
      ) +
      custom_theme + 
      theme(
        axis.line = element_line(color = "black"),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = "none"
      )

      
    
    bivar_plot <- ggplot() +
      geom_abline(slope = 1, intercept = 0) +
      geom_point(
        data = freq_bivar, 
        aes(x = TDN_freq, y = TP_freq, 
            size = TP_num_sites, color = freq_fisher_test)) +
      geom_point(
        data = dplyr::filter(freq_bivar, adj_freq_test <= 0.05, pct_chg > 0),
        aes(x = TDN_freq, y = TP_freq, size = TP_num_sites),
        shape = 21, color = "blue") +
      geom_point(
        data = dplyr::filter(freq_bivar, adj_freq_test <= 0.05, pct_chg < 0),
        aes(x = TDN_freq, y = TP_freq, size = TP_num_sites),
        shape = 21, color = "red") +
      geom_text_repel(
        data = key_enrich_freq_genes,
        aes(x = TDN_freq, y = TP_freq, label = gene_name),
        nudge_x = -0.5, nudge_y = 1, segment.alpha = 0.25,
        box.padding = unit(0.3, "lines"), size = 3) +
      geom_text_repel(
        data = key_deplet_freq_genes,
        aes(x = TDN_freq, y = TP_freq, label = gene_name),
        nudge_x = 0.5, nudge_y = -1, segment.alpha = 0.25,
        box.padding = unit(0.3, "lines"), size = 3) +
      scale_color_continuous(low = "#56B1F7", high = "#132B43") +
      scale_y_continuous(
        trans = log_trans(), 
        breaks = log_breaks(), 
        labels = scales::scientific) +
      scale_x_continuous(
        trans = log_trans(), 
        breaks = log_breaks(), 
        labels = scales::scientific) +
      labs(
        x = "Transduction Product Integration\nFrequency (1 / kb)",
        y = "Patient Sample Integration Frequency (1 / kb)",
        color = "Enriched\nP-value",
        size = "Number of\nIntegrations") +
      custom_theme +
      theme(
        legend.position = "right", 
        legend.box = "vertical",
        legend.direction = "vertical",
        axis.line = element_line(color = "black")
      )
    
})

gene_freq_bivar$vol_plot
```
Figure 2. (D) Volcano plot showing genes where integration frequency was enriched or depleted during growth in patients. The total number of integration sites in each transcription unit was quantified for the pre-infusion and post-transplant samples, and normalized within each group. The two values were subtracted to obtain a normalized percent change (x-axis). Fisher’s exact test (corrected for multiple comparisons using the Benjamini-Hochberg method) was used to assess enrichment or depletion (y-axis). The x-axis shows the percent change in frequency, the y-axis shows inverse Log of the p-value.

```{r fig2E, fig.width=7, fig.height=3}
long_clone_plots$long_plots$`p03712-06`
```
Figure 2. (E) Example of a longitudinal expanded clone, from patient p03712-06. The x-axis shows the time points sampled, the y-axis shows the % relative abundance of each clone determined by SonicAbundance. The nearest gene, and the chromosomal location of each integration site (mapped on hg38) are indicated for the 10 most abundant clones. * indicates integrated within the indicated transcription unit.

\newpage
## Figure 4. Genomic and epigenetic features associated with vector integration. 
```{r generate_heatmap_data, eval=FALSE}
heatmap_data <- within(
  list(), {
    # Select TDN and Patient sites (d28) for heatmap
    # additionally split by responders and non-responders
    std_data <- bind_rows(list(
        "TDN" = as.data.frame(tdn_sites, row.names = NULL), 
        "D28" = as.data.frame(timepoint_sites, row.names = NULL)),
        .id = "type") %>%
      dplyr::select(type, patient, celltype, timepoint, specimen, posid) %>%
      dplyr::filter(type == "D28" & timepoint == "d28" | type == "TDN") %>%
      left_join(patient_data, by = "patient") %>%
      dplyr::mutate(
        seqnames = str_extract(posid, "[\\w]+"),
        strand = str_extract(posid, "[+-]"),
        pos = as.numeric(str_extract(posid, "[0-9]+$")),
        setname = paste0(type, " - ", determinant_response)) %>%
      dplyr::select(seqnames, strand, pos, setname, posid) %>% 
      dplyr::filter(seqnames %in% c(paste0("chr", 1:22), "chrX", "chrY")) %>%
      as.data.frame()
    
    std_data <- split(std_data, std_data$setname)
    std_heatmap_data <- bind_rows(lapply(std_data, function(df){
        if(nrow(df) < 5000){
          return(df)
        }else{
          idx <- sample(
            seq_len(nrow(df)), 5000, replace = FALSE)
          return(df[idx,])
        }})) %>%
      dplyr::mutate(sampleName = setname, position = pos, refGenome = "hg38") %>%
      dplyr::select(seqnames, strand, position, sampleName, refGenome)

    std_heatmap_sample_info <- std_heatmap_data %>%
      dplyr::group_by(sampleName) %>%
      dplyr::summarise(
        GTSP = unique(sampleName), 
        patient = "Mock") %>%
      dplyr::ungroup() 

    write.csv(
      std_heatmap_data, 
      file.path(outputDir, "manuscript_std_heatmap_sites.csv"), 
      row.names = FALSE, quote = FALSE)
    
    write.csv(
      std_heatmap_sample_info, 
      file.path(outputDir, "manuscript_std_heatmap_samples.csv"), 
      row.names = FALSE, quote = FALSE)
})
```

```{r fig4ABC, fig.width=6, fig.height=7.5}
# system call: /home/opt/R-3.4.0/bin/Rscript ~/dev/scripts/genomicHeatmapMaker/genomic_heatmap_from_file.R manuscript_std_heatmap_samples.csv -f manuscript_std_heatmap_sites.csv -o manuscript_genomic_std_heatmap -r hg38 -c ~/INSPIIRED/INSPIIRED.yml

# system call: /home/opt/R-3.4.0/bin/Rscript ~/dev/scripts/EpigeneticHeatmapMaker/epi_heatmap_from_file.R manuscript_std_heatmap_samples.csv -f manuscript_std_heatmap_sites.csv -t ~/dev/scripts/EpigeneticHeatmapMaker/CD4_epi_types.txt -o manuscript_epi_std_heatmap -c ~/INSPIIRED/INSPIIRED.yml

heatmap_data <- within(
  list(), {
    
    heatmap_sample_info <- read.csv(
      file.path(outputDir, "manuscript_std_heatmap_samples.csv")
    )

    heatmap_scale <- seq(0.2, 0.8, 0.1)
    
    heatmap_colors <- colorspace::diverge_hsv(
      length(heatmap_scale), h = c(240, 0), v = 1, power = 1)
    
    heatmap_sample_levels <- c(
      "TDN - CR_PRtd", "TDN - PR_NR", "D28 - CR_PRtd", "D28 - PR_NR"
    )
    
    heatmap_figure_labels <- gsub("_", "/", heatmap_sample_levels)

    stat_cuts <- c(0, 0.001, 0.01, 0.05, 1)

    
    # Genomic section ----
    gen_heatmap <- readRDS(
      file.path(outputDir, "manuscript_genomic_std_heatmap/roc.res.rds")
    )

    select_gen_features <- row.names(gen_heatmap$ROC)
    
    select_gen_features <- c(
      "start.dist", "general.width", "within_refSeq_gene", "GC.10k", 
      "CpG_density.10k", "DNaseI_count.10k"
    )
    
    preferred_gen_names <- c(
      "start.dist" = "Distance to Txn start",
      "general.width" = "Intergenic width", 
      "within_refSeq_gene" = "In Txn unit, RefSeq", 
      "GC.10k" = "GC Content", 
      "CpG_density.10k" = "CpG Density", 
      "DNaseI_count.10k" = "DNaseI"
    )

    gen_heatmap$ROC <- gen_heatmap$ROC[select_gen_features,]

    gen_comp_tdn_stats <- structure(cut(
        gen_heatmap$pvalues$op[select_gen_features, 6], 
        stat_cuts, 
        labels = c("***", " **", " * ", "   "), 
        include.lowest = TRUE
      ),
      names = select_gen_features
    )
    
    gen_comp_d28_stats <- structure(cut(
        gen_heatmap$pvalues$op[select_gen_features, 1], 
        stat_cuts, 
        labels = c("***", " **", " * ", "   "), 
        include.lowest = TRUE),
      names = select_gen_features
    )
    
    gen_comp_stats <- structure(
      paste0(gen_comp_tdn_stats, "|", gen_comp_d28_stats),
      names = names(gen_comp_tdn_stats)
    )
    
    gen_row_names <- paste0(
      preferred_gen_names[names(gen_comp_stats)], " - ", gen_comp_stats
    )

    gen_plot_data <- gen_heatmap$ROC %>%
      reshape2::melt() %>% 
      dplyr::mutate(
        feat = preferred_gen_names[Var1],
        comp.sym = gen_comp_stats[Var1],
        Var1 = paste0(preferred_gen_names[Var1], " - ", comp.sym),
        Var1 = factor(Var1, levels = gen_row_names), 
        Var2 = as.character(Var2),
        #Var2 = factor(Var2, levels = heatmap_sample_levels),
        feat = factor(feat, levels = rev(preferred_gen_names)),
        grp = " ",
        sig = as.vector(gen_heatmap$pvalues$np[select_gen_features,]),
        sym = cut(
          sig, stat_cuts, labels = c("***", " **", " * ", "   "), 
          include.lowest = TRUE)
      ) %>%
      tidyr::separate(
        col = Var2, into = c("timepoint", "response"), sep = " - "
      ) %>%
      dplyr::mutate(
        response = gsub("_", "/", response),
        response = factor(response, levels = c("Sig", "CR/PRtd", "PR/NR")),
        timepoint = ifelse(timepoint == "TDN", "Infusion\nProduct", "Day\n28"),
        timepoint = factor(
          timepoint, levels = c("Infusion\nProduct", "Day\n28")
        ),
        sym = ""
      )

    add_gen_data <- gen_plot_data %>%
      dplyr::mutate(comp.sym = as.character(comp.sym)) %>%
      tidyr::separate(
        col = comp.sym, into = c("tdn", "d28"), sep = "\\|"
      ) %>%
      dplyr::select(Var1, timepoint, response, feat, tdn, d28) %>%
      tidyr::gather(
        key = "comp", value = "sym", -Var1, -timepoint, -response, -feat
      ) %>%
      dplyr::filter(
        ifelse(timepoint == "Day\n28", comp == "d28", comp == "tdn")
      ) %>%
      dplyr::select(feat, timepoint, sym) %>%
      dplyr::mutate(
        value = 0.5,
        response = factor("Sig", levels = c("Sig", "CR/PRtd", "PR/NR"))
      )
    
    gen_plot_data <- gen_plot_data %>%
      dplyr::select(feat, timepoint, response, value, sym) %>%
      dplyr::bind_rows(add_gen_data)
  

    # Epigenetic section ----
    epi_heatmap <- bps_heatmap <- readRDS(
      file.path(outputDir, "manuscript_epi_std_heatmap/roc.res.rds"))

    select_epi_features <- c(
      "H2AK9ac.10Kb", "H2BK5me1.10Kb", "H2BK12ac.10Kb", "H3K4me2.10Kb", 
      "H3K4me3.10Kb", "H3K9me3.10Kb", "H3K14ac.10Kb", "H3K18ac.10Kb", 
      "H3K27me2.10Kb", "H3K36me1.10Kb", "H3K36me3.10Kb", "H3K79me1.10Kb",
      "H3K79me2.10Kb", "H3K79me3.10Kb", "H4K8ac.10Kb","H4K12ac.10Kb", 
      "H4K16ac.10Kb", "H4K20me1.10Kb", "H4R3me2.10Kb"
    )
    
    select_bound_proteins <- c(
      "Brd2_promoters.10Kb", "Brd3_promoters.10Kb", "Brd4_promoters.10Kb", 
      "CTCF.10Kb", "H2AZ.10Kb", "Rest_CD4_HDAC1.10Kb", "Rest_CD4_HDAC3.10Kb", 
      "Rest_CD4_HDAC6.10Kb", "HP1a_promoters.10Kb", "RestingNucleosomes.10Kb", 
      "NRSF.10Kb", "Rest_CD4_PCAF.10Kb","PolII.10Kb"
    )

    epi_heatmap$ROC <- epi_heatmap$ROC[select_epi_features,]
    bps_heatmap$ROC <- bps_heatmap$ROC[select_bound_proteins,]

    preferred_epi_names <- structure(
      gsub(".10Kb", "", select_epi_features),
      names = select_epi_features
    )
    
    preferred_bps_names <- c(
      "Brd2_promoters.10Kb" = "Brd2 promoters", 
      "Brd3_promoters.10Kb" = "Brd3 promoters", 
      "Brd4_promoters.10Kb" = "Brd4 promoters", 
      "CTCF.10Kb" = "CTCF", 
      "H2AZ.10Kb" = "H2AZ", 
      "Rest_CD4_HDAC1.10Kb" = "CD4+ HDAC1", 
      "Rest_CD4_HDAC3.10Kb" = "CD4+ HDAC3", 
      "Rest_CD4_HDAC6.10Kb" = "CD4+ HDAC6", 
      #"Act_CD4_HDAC6.10Kb" = "Activated CD4+ HDAC6", 
      "HP1a_promoters.10Kb" = "HP1a promoters", 
      "RestingNucleosomes.10Kb" = "Nucleosomes", 
      #"ActivatedNucleosomes.10Kb" = "Activated Nucleosomes", 
      "NRSF.10Kb" = "NRSF/REST",
      "Rest_CD4_PCAF.10Kb" = "CD4+ PCAF/KAT2B",
      "PolII.10Kb" = "PolII"
    )
    
    # Epigenetic data
    epi_comp_tdn_stats <- structure(cut(
        epi_heatmap$pvalues$op[select_epi_features, 6], 
        stat_cuts, 
        labels = c("***", " **", " * ", "   "), 
        include.lowest = TRUE
      ),
      names = select_epi_features
    )
    
    epi_comp_d28_stats <- structure(cut(
        epi_heatmap$pvalues$op[select_epi_features, 1], 
        stat_cuts, 
        labels = c("***", " **", " * ", "   "), 
        include.lowest = TRUE
      ),
      names = select_epi_features
    )
    
    epi_comp_stats <- structure(
      paste0(epi_comp_tdn_stats, "|", epi_comp_d28_stats),
      names = names(epi_comp_tdn_stats)
    )
    
    epi_row_names <- paste0(
      preferred_epi_names[names(epi_comp_tdn_stats)], " - ", epi_comp_stats
    )

    epi_plot_data <- epi_heatmap$ROC %>%
      reshape2::melt() %>% 
      dplyr::mutate(
        feat = preferred_epi_names[Var1],
        comp.sym = epi_comp_stats[Var1],
        grp = ifelse(as.integer(Var1) <= length(levels(Var1))/2, " ", "  "),    
        Var1 = paste0(preferred_epi_names[Var1], " - ", comp.sym),
        Var1 = factor(Var1, levels = rev(epi_row_names)), 
        Var2 = as.character(Var2),
        #Var2 = factor(Var2, levels = heatmap_sample_levels),
        feat = factor(feat, levels = rev(preferred_epi_names)),
        grp = " ",
        sig = as.vector(epi_heatmap$pvalues$np[select_epi_features,]),
        sym = cut(
          sig, stat_cuts, labels = c("***", " **", " * ", "   "), 
          include.lowest = TRUE)
      ) %>%
      tidyr::separate(
        col = Var2, into = c("timepoint", "response"), sep = " - "
      ) %>%
      dplyr::mutate(
        response = gsub("_", "/", response),
        response = factor(response, levels = c("Sig", "CR/PRtd", "PR/NR")),
        timepoint = ifelse(timepoint == "TDN", "Infusion\nProduct", "Day\n28"),
        timepoint = factor(
          timepoint, levels = c("Infusion\nProduct", "Day\n28")
        ),
        sym = ""
      )
        
    add_epi_data <- epi_plot_data %>%
      dplyr::mutate(comp.sym = as.character(comp.sym)) %>%
      tidyr::separate(
        col = comp.sym, into = c("tdn", "d28"), sep = "\\|"
      ) %>%
      dplyr::select(Var1, timepoint, response, feat, tdn, d28) %>%
      tidyr::gather(
        key = "comp", value = "sym", -Var1, -timepoint, -response, -feat
      ) %>%
      dplyr::filter(
        ifelse(timepoint == "Day\n28", comp == "d28", comp == "tdn")
      ) %>%
      dplyr::select(feat, timepoint, sym) %>%
      dplyr::mutate(
        value = 0.5,
        response = factor("Sig", levels = c("Sig", "CR/PRtd", "PR/NR"))
      )
    
    epi_plot_data <- epi_plot_data %>%
      dplyr::select(feat, timepoint, response, value, sym) %>%
      dplyr::bind_rows(add_epi_data)

    
    # Bound protein data ----
    bps_comp_tdn_stats <- structure(cut(
        bps_heatmap$pvalues$op[select_bound_proteins, 6], 
        stat_cuts, 
        labels = c("***", " **", " * ", "   "), 
        include.lowest = TRUE
      ),
      names = select_bound_proteins
    )
    
    bps_comp_d28_stats <- structure(cut(
        bps_heatmap$pvalues$op[select_bound_proteins, 1], 
        stat_cuts, 
        labels = c("***", " **", " * ", "   "), 
        include.lowest = TRUE
      ),
      names = select_bound_proteins
    )
    
    bps_comp_stats <- structure(
      paste0(bps_comp_tdn_stats, "|", bps_comp_d28_stats),
      names = names(bps_comp_tdn_stats)
    )
    
    bps_row_names <- paste0(
      preferred_bps_names[names(bps_comp_tdn_stats)], " - ", bps_comp_stats
    )

    bps_plot_data <- bps_heatmap$ROC %>%
      reshape2::melt() %>% 
      dplyr::mutate(
        feat = preferred_bps_names[Var1],
        comp.sym = bps_comp_stats[Var1],
        grp = ifelse(as.integer(Var1) <= length(levels(Var1))/2, " ", "  "),    
        Var1 = paste0(preferred_bps_names[Var1], " - ", comp.sym),
        Var1 = factor(Var1, levels = rev(bps_row_names)), 
        Var2 = as.character(Var2),
        #Var2 = factor(Var2, levels = heatmap_sample_levels),
        feat = factor(feat, levels = rev(preferred_bps_names)),
        grp = " ",
        sig = as.vector(bps_heatmap$pvalues$np[select_bound_proteins,]),
        sym = cut(
          sig, stat_cuts, labels = c("***", " **", " * ", "   "), 
          include.lowest = TRUE)
      ) %>%
      tidyr::separate(
        col = Var2, into = c("timepoint", "response"), sep = " - "
      ) %>%
      dplyr::mutate(
        response = gsub("_", "/", response),
        response = factor(response, levels = c("Sig", "CR/PRtd", "PR/NR")),
        timepoint = ifelse(timepoint == "TDN", "Infusion\nProduct", "Day\n28"),
        timepoint = factor(
          timepoint, levels = c("Infusion\nProduct", "Day\n28")
        ),
        sym = ""
      )

    add_bps_data <- bps_plot_data %>%
      dplyr::mutate(comp.sym = as.character(comp.sym)) %>%
      tidyr::separate(
        col = comp.sym, into = c("tdn", "d28"), sep = "\\|"
      ) %>%
      dplyr::select(Var1, timepoint, response, feat, tdn, d28) %>%
      tidyr::gather(
        key = "comp", value = "sym", -Var1, -timepoint, -response, -feat
      ) %>%
      dplyr::filter(
        ifelse(timepoint == "Day\n28", comp == "d28", comp == "tdn")
      ) %>%
      dplyr::select(feat, timepoint, sym) %>%
      dplyr::mutate(
        value = 0.5,
        response = factor("Sig", levels = c("Sig", "CR/PRtd", "PR/NR"))
      )
    
    bps_plot_data <- bps_plot_data %>%
      dplyr::select(feat, timepoint, response, value, sym) %>%
      dplyr::bind_rows(add_bps_data)
    
    
    # Formating and generating the individual plots ----
    composite_heatmap_data <- suppressWarnings(dplyr::bind_rows(
        gen_plot_data, epi_plot_data, bps_plot_data
      )) %>%
      dplyr::mutate(
        timepoint = factor(
          timepoint, levels = c("Infusion\nProduct", "Day\n28")
        ),
        response = gsub("Sig", " ", as.character(response)),
        response = factor(
          response, levels = c(" ", "CR/PRtd", "PR/NR")
        ),
        value = as.numeric(value)
      )
    
    genomic_heatmap_feats <- c(
      "Distance to Txn start", "Intergenic width", "In Txn unit, RefSeq", 
      "GC Content", "CpG Density", "DNaseI", "Brd2 promoters", 
      "Brd3 promoters", "Brd4 promoters"
    )
    
    epigenetic_heatmap_feats <- c(
      "H2AK9ac", "H2BK5me1", "H2BK12ac", "H3K4me2", "H3K4me3", "H3K9me3", 
      "H3K14ac", "H3K18ac", "H3K27me2", "H3K36me1", "H3K36me3", "H3K79me1", 
      "H3K79me2", "H3K79me3", "H4K8ac", "H4K12ac", "H4K16ac", "H4K20me1", 
      "H4R3me2"
    )
    
    bound_protein_feats <- c(
      "CTCF", "H2AZ", "CD4+ HDAC1", "CD4+ HDAC3", "CD4+ HDAC6", 
      "HP1a promoters", "Nucleosomes", "NRSF/REST", "CD4+ PCAF/KAT2B", "PolII"
    )
    
    gen_plot <- composite_heatmap_data %>%
      dplyr::filter(feat %in% genomic_heatmap_feats) %>%
      dplyr::mutate(feat = factor(
        feat, levels = rev(genomic_heatmap_feats)
      )) %>%
      ggplot() + 
      geom_tile(
        aes(x = response, y = feat, fill = value), 
        color = 'grey60'
      ) +
      geom_text(
        aes(
          x = response, y = feat, label = stringr::str_trim(sym)
        ), 
        color = "black", size = 3, 
        fontface = "bold", family = "Courier"
      ) + 
      facet_grid(. ~ timepoint) +
      scale_x_discrete(position = "top") +
      scale_fill_gradient2(
        breaks = c(0.2, 0.4, 0.6, 0.8), 
        low = heatmap_colors[1], 
        mid = heatmap_colors[round(length(heatmap_scale)/2)], 
        high = heatmap_colors[length(heatmap_scale)], 
        midpoint = 0.5
      ) +
      guides(fill = guide_colorbar(
        title.position = "left", title.hjust = 0.5, 
        direction = "horizontal"
      )) +
      labs(
        x = NULL, y = NULL, fill = "ROC\nScore",
        title = "A. Genomic"
      ) +
      custom_theme +
      theme(
        legend.position = "none",
        plot.title = element_text(hjust = 1),
        axis.text.x.top = element_text(
          angle = 90, hjust = 0, vjust = 0.5, size = 8),
        strip.background = element_rect(fill = "white", color = "black"),
        strip.placement = "outside",
        axis.line = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        aspect.ratio = length(genomic_heatmap_feats) / 
          (length(heatmap_sample_levels) - 1)
      )

    epi_plot <- composite_heatmap_data %>%
      dplyr::filter(feat %in% epigenetic_heatmap_feats) %>%
      dplyr::mutate(feat = factor(
        feat, levels = rev(epigenetic_heatmap_feats)
      )) %>%
      ggplot() + 
      geom_tile(
        aes(x = response, y = feat, fill = value), 
        color = 'grey60'
      ) +
      geom_text(
        aes(
          x = response, y = feat, label = stringr::str_trim(sym)
        ), 
        color = "black", size = 3, 
        fontface = "bold", family = "Courier"
      ) + 
      facet_grid(. ~ timepoint) +
      scale_x_discrete(position = "top") +
      scale_fill_gradient2(
        breaks = c(0.2, 0.4, 0.6, 0.8), 
        low = heatmap_colors[1], 
        mid = heatmap_colors[round(length(heatmap_scale)/2)], 
        high = heatmap_colors[length(heatmap_scale)], 
        midpoint = 0.5,
        limits = c(0.1, 0.9)
      ) +
      guides(fill = guide_colorbar(
        title.position = "left", title.hjust = 0.5, 
        direction = "horizontal"
      )) +
      labs(
        x = NULL, y = NULL, fill = "ROC\nScore",
        title = "C. Epigenetic"
      ) +
      custom_theme +
      theme(
        legend.position = "bottom",
        plot.title = element_text(hjust = 1),
        axis.text.x.top = element_text(
          angle = 90, hjust = 0, vjust = 0.5, size = 8),
        strip.background = element_rect(fill = "white", color = "black"),
        strip.placement = "outside",
        axis.line = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        aspect.ratio = length(epigenetic_heatmap_feats) / 
          (length(heatmap_sample_levels) - 1)
      )
    
    bps_plot <- composite_heatmap_data %>%
      dplyr::filter(feat %in% bound_protein_feats) %>%
      dplyr::mutate(feat = factor(
        feat, levels = rev(bound_protein_feats)
      )) %>%
      ggplot() + 
      geom_tile(
        aes(x = response, y = feat, fill = value), 
        color = 'grey60'
      ) +
      geom_text(
        aes(
          x = response, y = feat, label = stringr::str_trim(sym)
        ), 
        color = "black", size = 3, 
        fontface = "bold", family = "Courier"
      ) + 
      facet_grid(. ~ timepoint) +
      scale_x_discrete(position = "top") +
      scale_fill_gradient2(
        breaks = c(0.2, 0.4, 0.6, 0.8), 
        low = heatmap_colors[1], 
        mid = heatmap_colors[round(length(heatmap_scale)/2)], 
        high = heatmap_colors[length(heatmap_scale)], 
        midpoint = 0.5
      ) +
      guides(fill = guide_colorbar(
        title.position = "left", title.hjust = 0.5, 
        direction = "horizontal"
      )) +
      labs(
        x = NULL, y = NULL, fill = "ROC\nScore",
        title = "B. Bound Proteins"
      ) +
      custom_theme +
      theme(
        legend.position = "none",
        plot.title = element_text(hjust = 1),
        axis.text.x.top = element_text(
          angle = 90, hjust = 0, vjust = 0.5, size = 8),
        strip.background = element_rect(fill = "white", color = "black"),
        strip.placement = "outside",
        axis.line = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        aspect.ratio = length(bound_protein_feats) / 
          (length(heatmap_sample_levels) - 1)
      )

    heatmap_plots <- list(gen_plot, epi_plot, bps_plot)
})

grid.arrange(
  grobs = heatmap_data$heatmap_plots,
  layout_matrix = matrix(
    c(
      rep(c(rep(1, 10), rep(2, 8)), 12), 
      rep(c(rep(3, 10), rep(2, 8)), 12), 
      rep(3, 10), rep(NA, 8)
    ), 
    ncol = 18, byrow = TRUE
  )
)
```
Figure 4. Frequencey of integration near chromosomal features is associated with outcome. (A) Genomic features (B) chromosome-bound proteins and (C) epigenetic marks associated with vector integration frequency are shown for transduction products and day 28 peripherial blood samples. CR/PRtd and PR/NR are compared (columns) to mapped chromosomal features (rows). Associations are calculated by an ROC area method (41, 45). Values of the ROC area can vary between 0 (negatively associated) and 1 (positively associated), with 0.5 indicating no association. TU indicates transcription unit. All epigenetic features were assessed within a 10 kb window. Asterisks beside the heatmap indicate comparisons between clinical response groups; separate analyses were carried out for TDN on left and Day 28 on right. P-values were calculated using the Wald test using a Chi Square distribution; no correction for multiple comparisons was applied. p-value < 0.05 (\*), < 0.01 (\*\*), < 0.001 (\*\*\*).

```{r pop_summary}
specimen_population_summary <- within(
  list(), {
    # Specimen summary metrics
    specimen_summary <- summaries$specimen %>%
      dplyr::mutate(determinant_response = patient_data$determinant_response[
        match(patient, patient_data$patient)])
    
    # Plot and compare chao1 distributions between timepoint and response
    chao1_plot_data <- specimen_summary %>% 
      dplyr::select(
        patient, celltype, timepoint, Chao1, disease, determinant_response
      ) %>%
      dplyr::mutate(
        determinant_response = gsub(
          "_", "/", as.character(determinant_response)
        ),
        determinant_response = factor(
          determinant_response, levels = c("CR/PRtd", "PR/NR")
        )
      ) %>%
      dplyr::filter(
        timepoint %in% c("d0", "d28"), 
        celltype %in% c("Tcells", "PBL")
      ) %>%
      dplyr::mutate(
        Chao1 = log(Chao1, base = 10),
        timepoint = as.character(timepoint),
        timepoint = gsub("d0", "TDN", timepoint),
        timepoint = gsub("d28", "Day 28", timepoint),
        timepoint = factor(timepoint, levels = c("TDN", "Day 28"))
      )
      
    chao1_plot <- ggplot(chao1_plot_data, aes(x = timepoint, y = Chao1)) +
      stat_summary(
        mapping = aes(group = timepoint), fun.data = "mean_cl_normal", 
        color = "grey50", size = 0.5, geom = "crossbar", width = 0.5, 
        fatten = 5) +
      geom_point(position = position_jitter(width = 0.125)) +
      scale_y_continuous(breaks = c(0:5)) +
      facet_wrap(~ determinant_response, scales = "fixed", nrow = 1) + 
      labs(y = bquote("Estimated Population Size (" ~log[10]~ ")"), x = NULL) +
      custom_theme +
      theme(
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),
        strip.text = element_text(face = "plain", size = 12),
        strip.background = element_rect(color = "black"),
        axis.text = element_text(size = 11),
        axis.title = element_text(size = 12)
      )
    
    chao1_sig <- split(
      chao1_plot_data$Chao1, 
      paste0(
        chao1_plot_data$determinant_response, " - ", chao1_plot_data$timepoint))
    
    chao1_sig <- as.data.frame(
        matrix(names(chao1_sig)[
          t(combn(seq_along(chao1_sig), 2))], ncol = 2)) %>%
      dplyr::mutate(
        p.val = combn(seq_along(chao1_sig), 2, function(i){
          wilcox.test(x = chao1_sig[[i[1]]], y = chao1_sig[[i[2]]])$p.value
          }, simplify = TRUE)) %>%
      tidyr::separate(V1, into = c("response1", "timepoint1"), sep = " - ") %>%
      tidyr::separate(V2, into = c("response2", "timepoint2"), sep = " - ") %>%
      dplyr::filter(
        ifelse(
          response1 == response2, 
          timepoint1 != timepoint2, timepoint1 == timepoint2)) %>%
      dplyr::mutate(
        p.adj = p.adjust(p.val, method = "BH"),
        p.rnd = round(p.adj, digits = 4),
        sig = ifelse(p.rnd <= 0.05, "*", " "))
    
    # Plot and compare pct_in_txn between timepoint and response
    pct_txn_plot_data <- specimen_summary %>% 
      dplyr::select(
        patient, celltype, timepoint, pctTxnUnit, 
        pctNearTxnUn, disease, determinant_response) %>%
      dplyr::filter(
        disease == "CLL",
        timepoint %in% c("d0", "d28"), 
        celltype %in% c("Tcells", "PBL")) %>%
      dplyr::mutate(
        timepoint = as.character(timepoint),
        timepoint = gsub("d0", "TDN", timepoint),
        timepoint = gsub("d28", "Day 28", timepoint),
        timepoint = factor(timepoint, levels = c("TDN", "Day 28")))
      
    pct_txn_plot <- ggplot(
        pct_txn_plot_data, aes(x = timepoint, y = pctTxnUnit)) +
      stat_summary(
        mapping = aes(group = timepoint), fun.data = "mean_cl_normal", 
        color = "grey50", size = 0.5, geom = "crossbar", width = 0.5, 
        fatten = 5) +
      geom_point(position = position_jitter(width = 0.125)) +
      scale_y_continuous(breaks = pretty_breaks()) +
      facet_wrap(~ determinant_response, scales = "fixed", nrow = 1) + 
      labs(y = "Percent of Integrations within Txn Units", x = NULL) +
      custom_theme
    
    pct_txn_sig <- split(
      pct_txn_plot_data$pctTxnUnit, 
      paste0(
        pct_txn_plot_data$determinant_response, " - ", pct_txn_plot_data$timepoint))
    
    pct_txn_sig <- as.data.frame(
        matrix(names(pct_txn_sig)[
          t(combn(seq_along(pct_txn_sig), 2))], ncol = 2)) %>%
      dplyr::mutate(
        p.val = combn(seq_along(pct_txn_sig), 2, function(i){
          wilcox.test(x = pct_txn_sig[[i[1]]], y = pct_txn_sig[[i[2]]])$p.value
          }, simplify = TRUE)) %>%
      tidyr::separate(V1, into = c("response1", "timepoint1"), sep = " - ") %>%
      tidyr::separate(V2, into = c("response2", "timepoint2"), sep = " - ") %>%
      dplyr::filter(
        ifelse(
          response1 == response2, 
          timepoint1 != timepoint2, timepoint1 == timepoint2)) %>%
      dplyr::mutate(
        p.adj = p.adjust(p.val, method = "BH"),
        p.rnd = round(p.adj, digits = 4),
        sig = ifelse(p.rnd <= 0.05, "*", " "))
    
    # Plot and compare pct_in_txn between timepoint and response binned patients
    bin_pct_txn_plot_data <- specimen_summary %>% 
      dplyr::select(
        patient, celltype, timepoint, pctTxnUnit, 
        pctNearTxnUn, disease, determinant_response) %>%
      dplyr::filter(
        disease == "CLL",
        timepoint %in% c("d0", "d28"), 
        celltype %in% c("Tcells", "PBL")) %>%
      dplyr::mutate(
        timepoint = as.character(timepoint),
        timepoint = gsub("d0", "TDN", timepoint),
        timepoint = gsub("d28", "Day 28", timepoint),
        timepoint = factor(timepoint, levels = c("TDN", "Day 28")))
      
    bin_pct_txn_plot <- ggplot(
        bin_pct_txn_plot_data, aes(x = timepoint, y = pctTxnUnit)) +
      stat_summary(
        fun.data = "mean_cl_normal", 
        color = "grey50", size = 0.5, geom = "crossbar", width = 0.5, 
        fatten = 5) +
      geom_point(position = position_jitter(width = 0.125)) +
      scale_y_continuous(breaks = pretty_breaks()) +
      labs(y = "Percent of Integrations within Txn Units", x = NULL) +
      custom_theme +
      theme(
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black"),
        strip.text = element_text(face = "plain", size = 12),
        axis.text = element_text(size = 11),
        axis.title = element_text(size = 12))

    bin_pct_txn_sig <- split(
      bin_pct_txn_plot_data$pctTxnUnit, bin_pct_txn_plot_data$timepoint)
    
    bin_pct_txn_sig <- as.data.frame(
        matrix(names(bin_pct_txn_sig)[
          t(combn(seq_along(bin_pct_txn_sig), 2))], ncol = 2)) %>%
      dplyr::mutate(
        p.val = combn(seq_along(bin_pct_txn_sig), 2, function(i){
          wilcox.test(
            x = bin_pct_txn_sig[[i[1]]], y = bin_pct_txn_sig[[i[2]]])$p.value
          }, simplify = TRUE)) %>%
      dplyr::rename("timepoint1" = V1, "timepoint2" = V2) %>%
      dplyr::mutate(
        p.rnd = round(p.val, digits = 4),
        sig = ifelse(p.rnd <= 0.05, "*", " "))
})
```

```{r fig4D, fig.width=4, fig.height=3}
specimen_population_summary$chao1_plot
pandoc.table(
  specimen_population_summary$chao1_sig, 
  style = "simple", split.table = Inf, digits = 3)
```

Figure 4. (D) Right: box plot representation of Chao1 estimated population sizes for responders (CR and PRtd), comparing the transduction product and day 28 samples (PR and NR). Left: box plot representations of Chao1 estimated population sizes for nonresponders, comparing the transduction products and day 28 samples (p-values – CR/PRtd-TDN ~ PR/NR-TDN: 0.033, CR/PRtd-TDN ~ CR/PRtd-Day 28: < 0.001, PR/NR-TDN ~ PR/NR-Day 28: < 0.001, calculated using Wilcoxon tests with a Benjamini-Hochberg correction for multiple comparisons). Sources of annotation include: (20, 67-72).  

\newpage
## Figure 5. Predicting clinical outcome from integration site data.
```{r model_setup}
model_analysis <- within(
  list(), {
    set.seed(714)

    packs <- c(
      "doMC", "glmnet", "spraphal", "caret", "data.table", 
      "magrittr", "tidyverse")
    packs_loaded <- suppressMessages(
      sapply(packs, require, character.only = TRUE))
    if(!all(packs_loaded)){
      print(
        data.frame(
          "R-Packages" = names(packs_loaded), "Loaded" = packs_loaded), 
        row.names = FALSE)
      stop("Check dependancies.")
    }

    rm(packs, packs_loaded)

    registerDoMC(cores = numCores)

    # Load patient metadata ----
    data_dir <- "~/dev/projects/CART19/cart19_analyses/processed_data"
    ref_data_dir <- "~/data/projects/CART19/Determinants_Transcript"
    working_dir <- "~/dev/projects/CART19/cart19_analyses"

    all_specimen_data <- file.path(data_dir, "cart19_specimen_summary.csv") %>%
      read.csv() %>%
      dplyr::select(
        specimen, celltype, timepoint, patient, disease, response,
        simple_response, general_response, numUniqSites) %>%
      dplyr::mutate(
        disease = factor(disease, levels = c("pALL", "aALL", "CLL")),
        response = factor(response, levels = c(
          "None", "Partial", "Partial\nw TnDz", "Complete", 
          "Complete\nw relapse")),
        simple_response = factor(
          simple_response, levels = c("None", "Partial", "Complete")),
        general_response = factor(
          general_response, levels = c("Non-responder", "Responder")),
        determinant_response = factor(ifelse(
          response %in% c(
            "Complete", "Partial\nw TnDz", "Complete\nw relapse"), 
          "CR_PRtd", "PR_NR")),
        clin_trial = stringr::str_extract(patient, "[0-9]+"))

    specimen_data <- dplyr::filter(
      all_specimen_data, 
      disease == "CLL", clin_trial %in% std_clin_trials)

    patient_tdn_specimens <- dplyr::filter(
      specimen_data, 
      timepoint == "d0", celltype == "Tcells", numUniqSites >= 10)

    patient_d28_specimens <- dplyr::filter(
        specimen_data, 
        timepoint %in% c("d25", "d28"), 
        celltype == "PBL", 
        numUniqSites >= 10) %>%
      dplyr::mutate(timepoint = factor(timepoint, levels = c("d25", "d28"))) %>% 
      dplyr::group_by(patient) %>%
      dplyr::arrange(patient, timepoint) %>%
      dplyr::mutate(id = seq_len(n())) %>%
      top_n(1, 1/id) %>%
      dplyr::ungroup() %>%
      dplyr::select(-id) %>%
      dplyr::arrange(disease, response, patient)
    
    ibru_tdn_specimens <- dplyr::filter(
      all_specimen_data,
      timepoint == "d0", celltype == "Tcells", numUniqSites >= 10, 
        !clin_trial %in% std_clin_trials, !is.na(response))

    # Set plot theme ----
    base_theme <- theme_bw() + 
      theme(
        panel.border = element_blank(), 
        axis.line = element_line(color = "black"), 
        panel.grid = element_blank(), 
        strip.background = element_rect(fill = "white"), 
        strip.text = element_text(face = "bold", color = "black"),
        axis.text = element_text(face = "bold", color = "black"), 
        axis.title = element_text(size = 9, face = "bold", color = "black"), 
      legend.title = element_text(face = "bold", color = "black"),
      legend.position = "bottom")
    theme_set(base_theme)

    # Additional processing functions ----
    # The center_scale() function is useful if you have multiple matrices that 
    # may need to be centered and scaled by a different set of values than 
    # their own. If input is only one matrix, then the input matrix will be
    # centered and scaled to itself. If two matrices are supplied, the second
    # will act as the training matrix and the means and standard deviation from
    # the second matrix will be applied to the first matrix for centering and
    # scaling. Models, like PCA, can be built on scaled data, but if you want to
    # use a model like that on additional data, than the additional data needs 
    # to be scaled in the same manner for accuracy.
    center_scale <- function(input, trn = NULL){
      if(is.null(trn)) trn <- input
      means <- apply(trn, 2, mean)
      stdevs <- apply(trn, 2, sd)
      t(apply(input, 1, function(x) (x - means) / stdevs))
    }
    
    # Method to normalized a numerical vector or matrix to proportions.
    normalize <- function(x){
      stopifnot(is.numeric(x))
      x/sum(x)
    } 
     
    # Calculate the within class variance or scatter matrix, used in LDA
    within_class_scatter_matrix <- function(D, cl){
      cl <- factor(cl, levels = unique(cl))
      Reduce("+", lapply(seq_len(length(unique(cl))), function(k){
        d <- D[as.integer(cl) == k,]
        m <- colMeans(d)
        sc_mat <- d - matrix(rep(m, nrow(d)), nrow = nrow(d), byrow = TRUE)
        t(sc_mat) %*% sc_mat
      }))
    }
    
    # Calculate the between class variance or scatter matrix, used in LDA
    between_class_scatter_matrix <- function(D, cl){
      cl_means <- as.data.frame(D) %>%
        dplyr::mutate(cl = factor(cl, levels = unique(cl))) %>%
        dplyr::arrange(cl) %>%
        dplyr::group_by(cl) %>%
        dplyr::summarise_all(mean) %>%
        dplyr::ungroup() %>%
        dplyr::select(-cl) %>%
        as.matrix()
      
      tot_means <- colMeans(D)
      
      cl_N <- table(factor(cl, levels = unique(cl)))
      
      Reduce("+", lapply(seq_len(length(unique(cl))), function(k){
        k_m <- cl_means[k, , drop = FALSE] - tot_means
        cl_N[k] * (t(k_m) %*% k_m)
      }))
    }

    # Linear Discriminant Analysis (LDA) function for identifying components 
    # that tidyr::separate two or more classes given a dimensional input dataset 
    # (D, matrix) with classifications (cl). Scale will scale the data prior 
    # to analysis, change to FALSE if data has already been scaled. Log 
    # transform the data (log_trans) prior to analysis to analyze the data on 
    # a different scale, associated (base) option to change the base of 
    # the logrithm. 
    lineda <- function(D, cl, scale = TRUE, log_trans = FALSE, base = 10){
      if(log_trans) D <- log(D, base = base)
      if(scale) D <- apply(D, 2, function(x) (x - mean(x)) / sd(x))
      Sw <- within_class_scatter_matrix(D, cl)
      Sb <- between_class_scatter_matrix(D, cl)
      W <- svd( t(solve(Sw)) %*% Sb )
      svo <- order(W$d, decreasing = TRUE)
      Ws <- list()
      Ws$values <- W$d[svo[seq_len(length(unique(cl))-1)]]
      Ws$rotation <- W$u[,svo[seq_len(length(unique(cl))-1)], drop = FALSE]
      Ws$orth_rot <- W$v[,svo[seq_len(length(unique(cl))-1)], drop = FALSE]
      row.names(Ws$rotation) <- row.names(Ws$orth_rot) <- row.names(Sw)
      colnames(Ws$rotation) <- colnames(Ws$orth_rot) <- paste0(
        "LD", seq_len(ncol(Ws$rotation)))
      Ws$explained <- 100 * Ws$values / sum(Ws$values, na.rm = TRUE)
      Y <- D %*% (
        Ws$rotation %*% diag(sqrt(Ws$values), nrow = length(Ws$values)))
      rownames(Y) <- rownames(D)
      colnames(Y) <- colnames(Ws$rotation)
      return(list("trans" = Y, "svd" = Ws))
    }

    # Plot a multivariate analysis, such as PCA or LDA. Only selects the first 
    # two components for plotting. Additionally supply a classification vector
    # (cl) that will color the points differently on the output plot. Output is 
    # a ggplot object and can be further manipulated with the ggplot2 package.
    plot_mva <- function(D, cl){
      stopifnot(ncol(D) >= 2)
      Y <- as.data.frame(D[,1:2]) %>%
        dplyr::mutate("Class" = cl)
      names(Y) <- c("V1", "V2", "Class")
      
      Ym <- Y %>%
        dplyr::group_by(Class) %>%
        dplyr::summarise_all(mean) %>%
        dplyr::ungroup()
      
      Yl <- Y %>%
        dplyr::mutate(
          E1 = Ym$V1[match(Class, Ym$Class)],
          E2 = Ym$V2[match(Class, Ym$Class)])
      
      ggplot() + 
        geom_hline(yintercept = 0, color = "grey70") +
        geom_vline(xintercept = 0, color = "grey70") +
        geom_segment(
          data = Yl, 
          aes(x = V1, xend = E1, y = V2, yend = E2, color = Class)) +
        stat_ellipse(data = Y, aes(x = V1, y = V2, color = Class)) +
        geom_point(
          data = Y, aes(x = V1, y = V2, fill = Class),
          size = 3, color = "white", shape = 21) +
        geom_point(
          data = Ym, aes(x = V1, y = V2, fill = Class),
          size = 5, color = "white", shape = 24) +
        geom_rug(data = Y, aes(x = V1, y = V2, color = Class), sides = "b") +
        scale_color_brewer(type = "qual", palette = "Set1") +
        scale_fill_brewer(type = "qual", palette = "Set1")
    }

    # Plot data in on a Receiver Operator Characteristic curve. The logic vector 
    # should indicate a logical outcome of predicting one classification, 
    # i.e. if two classes exist (A and B), then the logic vector can equal 
    # logic <- class == "A". Data should be a numerical vector ... . Output is 
    # a ggplot object and can be further manipulated with the ggplot2 package.
    plot_roc <- function(logic, data, group = NULL, 
                         ties.method = "average", na.rm = FALSE, rdm.seed = 714){
      stopifnot(is.logical(logic))
      stopifnot(is.numeric(data)) 
      
      if(is.null(group)) group <- rep(1, length(logic))
      
      if(na.rm){
        na_idx <- is.na(data)
        logic <- logic[!na_idx]
        data <- data[!na_idx]
        group <- group[!na_idx]
      }
      
      grps <- structure(unique(group), names = unique(group))
      
      roc_data <- bind_rows(lapply(grps, function(grp){
        set.seed(rdm.seed)
        is_grp <- group == grp
        d <- data[is_grp]
        log <- logic[is_grp]
        x <- d[!log]
        y <- d[log]
        m <- sum(!log)
        n <- sum(log)
        x.ranks <- rank(x, ties.method = ties.method)
        y.ranks <- rank(y, ties.method = ties.method)
        is.x <- rep( c(TRUE,FALSE), c( m, n ))
        xy.ord <- is.x[order( 1/rank(c(x,y), ties.method = ties.method) )]
        xy.mag <- ifelse(xy.ord, 1/m, 1/n)
        data.frame(
          x.mag = c(0, cumsum(ifelse(xy.ord, xy.mag, 0))),
          y.mag = c(0, cumsum(ifelse(xy.ord, 0, xy.mag)))) %>%
          dplyr::group_by(y.mag) %>%
          dplyr::mutate(auc.i = ifelse(
            (max(x.mag) - min(x.mag)) > 0, 
            (max(x.mag) - min(x.mag)) * y.mag / n(), 0)) %>%
          dplyr::ungroup() %>%
          as.data.frame() }), .id = "grp") %>%
        dplyr::mutate(grp = factor(grp, unique(group)))
      
      plot_auc_data <- roc_data %>%
        dplyr::group_by(grp) %>%
        dplyr::summarise(auc = sum(auc.i)) %>%
        dplyr::ungroup() %>% as.data.frame()
      
      # Calculate theta
      theta_data <- bind_rows(lapply(grps, function(grp){
        set.seed(rdm.seed)
        is_grp <- group == grp
        d <- data[is_grp]
        log <- logic[is_grp]
        x <- d[!log]
        y <- d[log]
        m <- sum(!log)
        n <- sum(log)
        x.ranks <- rank(x, ties.method = ties.method)
        y.ranks <- rank(y, ties.method = ties.method)
        is.x <- rep( c(TRUE,FALSE), c( m, n ))
        
        xy.ranks <- split(rank(c(x,y), ties.method = ties.method), is.x)
        V.10 <- 1 - ( (xy.ranks[[2]] - x.ranks) / n )
        V.01 <- (xy.ranks[[1]] - y.ranks) / m 
        theta.hat <- mean(V.10)
        
        # Not sure the varience is calculated right as the 
        # hotROCs:::ROC.DDCP does something a little different with multiple
        # tested variables, maybe a correction for multiple comparisons that
        # isn't included here.
        S.10 <- var(V.10)
        S.01 <- var(V.01)
        S <- S.10/m + S.01/n
        
        res <- data.frame(theta = theta.hat, var = S) }), .id = "grp")
      
      p <- ggplot(roc_data, aes(x = x.mag, y = y.mag)) + 
        geom_abline(slope = 1, intercept = 0, color = "grey50") +
        geom_ribbon(aes(ymin = 0, ymax = y.mag, fill = grp), alpha = 0.1) + 
        geom_line(aes(color = grp)) + 
        scale_color_brewer(type = "qual", palette = "Set1") +
        scale_fill_brewer(type = "qual", palette = "Set1") +
        labs(x = "False Positive Rate", y = "True Positive Rate")
      
      if(length(unique(group)) == 1) p <- p + theme(legend.position = "none")
      if(nrow(plot_auc_data) == 1){
        p <- p + annotate(
          "text", x = 0.7, y = 0.1, size = 2.5,
          label = paste0("ROC.AUC=", round(plot_auc_data$auc, digits = 3)))
      }else{
        pander::pander(plot_auc_data)
      }
      p
    }

    # Plot a glmnet model cross-validation performance. Supply the output of 
    # glmnet::cv.glmnet() and the results will be plotted in a similar fashion 
    # to calling plot on the same object, the output will however be a ggplot
    # object and can be further manipulated by the ggplot2 package.
    plot_lasso <- function(glmnet_model, minOnly = FALSE){
      df <- data.frame(
          glmnet_model[c("lambda", "cvm", "cvsd", "cvup", "cvlo", "nzero")]) %>%
        dplyr::mutate(
          loglambda = log(lambda),
          fit = ifelse(
            lambda < glmnet_model$lambda.min, "over", 
            ifelse(lambda <= glmnet_model$lambda.1se, "optimal", "under")),
          fit = factor(fit, levels = c("over", "optimal", "under")),
          yzero = rep(0.9, n()),
          inc_y = rev(rep(c(TRUE, rep(FALSE, 3)), 50)[seq_len(n())]))
      
      if(minOnly){
        v_seg_x <- log(glmnet_model$lambda.min)
        v_seg_y <- -Inf
        v_seg_yend <- 0.85
        h_seg_x <- log(glmnet_model$lambda.min)
        h_seg_y <- c(glmnet_model$cvm[match(
            glmnet_model$lambda.min, glmnet_model$lambda)])
        h_seg_xend <- c(Inf)
      }else{
        v_seg_x <- log(c(glmnet_model$lambda.min, glmnet_model$lambda.1se))
        v_seg_y <- c(-Inf, -Inf)
        v_seg_yend <- c(0.85, 0.85)
        h_seg_x <- log(c(glmnet_model$lambda.min, glmnet_model$lambda.1se))
        h_seg_y <- c(glmnet_model$cvm[match(
            c(glmnet_model$lambda.min, glmnet_model$lambda.1se), 
            glmnet_model$lambda)])
        h_seg_xend <- c(Inf, Inf)
      }
      
      ggplot() +
        annotate(
          "segment", x = v_seg_x, y = v_seg_y, 
          xend = v_seg_x, yend = v_seg_yend,
          linetype = "dotted", color = "grey50") +
        annotate(
          "segment", x = h_seg_x, y = h_seg_y, 
          xend = h_seg_xend, yend = h_seg_y,
          linetype = "dotted", color = "grey50") +
        geom_errorbar(
          data = df, 
          aes(x = loglambda, ymin = cvlo, ymax = cvup, color = fit), 
          size = 0.25) +
        geom_point(data = df, aes(x = loglambda, y = cvm, color = fit)) +
        geom_text(
          data = df[df$inc_y,],
          aes(x = loglambda, y = yzero, label = nzero, color = fit), 
          show.legend = FALSE, size = 2.5) +
        scale_color_brewer(palette = "Set1") +
        scale_y_continuous(
          sec.axis = sec_axis(
            trans = ~., breaks = h_seg_y, 
            labels = round(h_seg_y, digits = 2))) +
        labs(
          color = "Model Fit", x = "Ln(Lambda)", y = "Misclassification Error")
    }

    # A modified plot_lasso for manuscript figures.
    plot_lasso_mod <- function(glmnet_model, custom_breaks, minOnly = FALSE){
      df <- data.frame(
          glmnet_model[c("lambda", "cvm", "cvsd", "cvup", "cvlo", "nzero")]) %>%
        dplyr::mutate(
          loglambda = log(lambda),
          fit = ifelse(
            lambda < glmnet_model$lambda.min, "over", 
            ifelse(lambda <= glmnet_model$lambda.1se, "optimal", "under")),
          fit = factor(fit, levels = c("over", "optimal", "under")),
          yzero = rep(0.9, n()),
          inc_y = rev(rep(c(TRUE, rep(FALSE, 3)), 50)[seq_len(n())]),
          ori_n = !rev(duplicated(rev(nzero))),
          mark_n = ori_n & nzero %in% custom_breaks)
      
      break_marks <- dplyr::filter(df, mark_n) %>%
        dplyr::distinct(nzero, loglambda)
      
      if(minOnly){
        v_seg_x <- log(glmnet_model$lambda.min)
        v_seg_y <- -Inf
        v_seg_yend <- 0.85
        h_seg_x <- log(glmnet_model$lambda.min)
        h_seg_y <- c(glmnet_model$cvm[match(
            glmnet_model$lambda.min, glmnet_model$lambda)])
        h_seg_xend <- c(Inf)
      }else{
        v_seg_x <- log(c(glmnet_model$lambda.min, glmnet_model$lambda.1se))
        v_seg_y <- c(-Inf, -Inf)
        v_seg_yend <- c(0.85, 0.85)
        h_seg_x <- log(c(glmnet_model$lambda.min, glmnet_model$lambda.1se))
        h_seg_y <- c(glmnet_model$cvm[match(
            c(glmnet_model$lambda.min, glmnet_model$lambda.1se), 
            glmnet_model$lambda)])
        h_seg_xend <- c(Inf, Inf)
      }
      
      ggplot() +
        annotate(
          "segment", x = v_seg_x, y = v_seg_y, 
          xend = v_seg_x, yend = v_seg_yend,
          linetype = "dotted", color = "grey50") +
        annotate(
          "segment", x = h_seg_x, y = h_seg_y, 
          xend = h_seg_xend, yend = h_seg_y,
          linetype = "dotted", color = "grey50") +
        geom_errorbar(
          data = df, 
          aes(x = loglambda, ymin = cvlo, ymax = cvup, color = fit), 
          size = 0.25) +
        geom_point(data = df, aes(x = loglambda, y = cvm, color = fit)) +
        scale_color_brewer(palette = "Set1") +
        scale_x_continuous(
          breaks = break_marks$loglambda, labels = break_marks$nzero) +
        scale_y_continuous(
          sec.axis = sec_axis(
            trans = ~., breaks = h_seg_y, 
            labels = round(h_seg_y, digits = 2))) +
        labs(
          color = "Model Fit", 
          x = "Model Complexity\n<-----[please change me to a real arrow ;)]", 
          y = "Misclassification Error")
    }
  }
)
```

```{r model_analysis}
model_analysis <- within(
  model_analysis, {
    
    # Data prep ----
    # Population, genomic, and epigenomic feature summarys of tdn products
    # TDN specimens are defined by celltype == "Tcells", and timepoint == "d0"
    # Additionally, there are sorted samples, but these are not included within 
    # the analysis. For now, we are using all patients (treated for pALL, aALL,
    # and CLL). Further, we are using the designation for patient response as 
    # "Non-Responder" including clinical responses as "None" and "Partial", and 
    # "Responder" including clinical responses as "Partial w TnDz", "Complete", 
    # and "Complete w relapse".

    tdn_data <- file.path(data_dir, "cart19_specimen_summary.csv") %>%
      read.csv() %>%
      dplyr::filter(specimen %in% patient_tdn_specimens$specimen)
    
    d28_data <- file.path(data_dir, "cart19_specimen_summary.csv") %>%
      read.csv() %>%
      dplyr::filter(specimen %in% patient_d28_specimens$specimen)
    
    ibru_data <- file.path(data_dir, "cart19_specimen_summary.csv") %>%
      read.csv() %>%
      dplyr::filter(specimen %in% ibru_tdn_specimens$specimen)
    
    # Data matrix with patients as rownames
    tdn_mat <- as.matrix(
      tdn_data[,(which(names(tdn_data) == "specimen")+1):ncol(tdn_data)])
    rownames(tdn_mat) <- tdn_data$patient
    tdn_mat <- tdn_mat[patient_tdn_specimens$patient,]
    
    d28_mat <- as.matrix(
      d28_data[,(which(names(d28_data) == "specimen")+1):ncol(d28_data)])
    rownames(d28_mat) <- d28_data$patient
    d28_mat <- d28_mat[patient_d28_specimens$patient,]
    
    ibru_mat <- as.matrix(
      ibru_data[,(which(names(ibru_data) == "specimen")+1):ncol(ibru_data)])
    rownames(ibru_mat) <- ibru_data$patient
    ibru_mat <- ibru_mat[ibru_tdn_specimens$patient,]
    
    # Patient and response vectors
    pats_tdn <- patient_tdn_specimens$patient
    resp_tdn <- patient_tdn_specimens$determinant_response
    vars <- colnames(tdn_mat)
    
    pats_d28 <- patient_d28_specimens$patient
    resp_d28 <- patient_d28_specimens$determinant_response

    pats_ibru <- ibru_tdn_specimens$patient
    resp_ibru <- ibru_tdn_specimens$determinant_response

    # Dimensional reduction ----
    # In this portion of the code, the input data for tdn and d28 samples are 
    # dimensionally reduced using PCA. This captures almost all the varibility 
    # of the data into principle components that have nearly zero covariance 
    # with each other. This last point is important for building models as 
    # components with high covarience can either confound the model building 
    # process or lead to the model choosing one while the other is nearly 
    # equally important, making interpretation challenging.
    
    tdn_scaled <- center_scale(tdn_mat)
    tdn_pca <- prcomp(x = tdn_scaled, retx = TRUE, scale. = FALSE)
    tdn_trans <- predict(tdn_pca, tdn_scaled)
    
    d28_scaled <- center_scale(d28_mat)
    d28_pca <- prcomp(x = d28_scaled, retx = TRUE, scale. = FALSE)
    d28_trans <- predict(d28_pca, d28_scaled)

    ibru_scaled <- center_scale(ibru_mat, tdn_mat)
    ibru_trans <- predict(tdn_pca, ibru_scaled)

    # Refine model ----
    # In this block of code, a model is refined / generated from the PCA data. 
    # Depending on the number of components included, the model can refine 
    # itself in different directions. Here a serial method is employed to
    # identify the best model by limiting the principle components of the input
    # data limited, starting with the largest contributor to data variance and 
    # increases by adding subsequent important components. Model evaluation is 
    # based on misclassification error, and is therefore minimized to select the
    # best model. 
    # This step really doesn't directly select the model, rather the number of 
    # PCs that need to be included to construct the best model. The 
    # cross-validation generates models through a leave-one out method and then 
    # bases the misclassification error on classifying the left-out sample. The 
    # cross-validation optimizes the lambda coefficient, or the penalty for 
    # inclusion of additional components, as well as the individual beta 
    # coefficients which weight the components in the general linear model. 
    tdn_pca_cutoff <- data.frame(
        component = 2:ncol(tdn_trans),
        misclass = sapply(2:ncol(tdn_trans), function(cutoff){
          cv <- cv.glmnet(
            x = tdn_trans[, seq_len(cutoff), drop = FALSE], y = resp_tdn, 
            family = "binomial", type.measure = "class", 
            nfold = nrow(tdn_trans), grouped = FALSE, parallel = TRUE)
          cv$cvm[match(cv$lambda.1se, cv$lambda)]
        })) %>%
      dplyr::filter(misclass == min(misclass)) %>%
      dplyr::filter(component == min(component)) %$%
      component
    
    d28_pca_cutoff <- data.frame(
        component = 2:ncol(d28_trans),
        misclass = sapply(2:ncol(d28_trans), function(cutoff){
          cv <- cv.glmnet(
            x = d28_trans[, seq_len(cutoff), drop = FALSE], y = resp_d28, 
            family = "binomial", type.measure = "class", 
            nfold = nrow(d28_trans), grouped = FALSE, parallel = TRUE)
          cv$cvm[match(cv$lambda.1se, cv$lambda)]
        })) %>%
      dplyr::filter(misclass == min(misclass)) %>%
      dplyr::filter(component == min(component)) %$%
      component


    # Generate LASSO models ----
    # Using the cutoff for components of the original data, below we construct a 
    # lasso regression model on the patients. This method does a leave-one-out 
    # cross validation as well and selects the lease complex but best performing
    # model to classify the input data for clincial response. 

    cv_tdn_pca <- cv.glmnet(
      x = tdn_trans[,seq_len(tdn_pca_cutoff)], y = resp_tdn, 
      family = "binomial", alpha = 1, type.measure = "class", 
      nfold = nrow(tdn_trans), grouped = FALSE, parallel = TRUE, keep = TRUE)
    
    tdn_min_model <- glmnet(
      x = tdn_trans[,seq_len(tdn_pca_cutoff)], y = resp_tdn, 
      family = "binomial", alpha = 1, lambda = cv_tdn_pca$lambda.min)
    
    cv_d28_pca <- cv.glmnet(
      x = d28_trans[,seq_len(d28_pca_cutoff)], y = resp_d28, 
      family = "binomial", alpha = 1, type.measure = "class", 
      nfold = nrow(d28_trans), grouped = FALSE, parallel = TRUE, keep = TRUE)
    
    d28_min_model <- glmnet(
      x = d28_trans[,seq_len(d28_pca_cutoff)], y = resp_d28, 
      family = "binomial", alpha = 1, lambda = cv_d28_pca$lambda.min)

    # Feature annotations ----
    all_features <- colnames(tdn_mat)
    format_features <- structure(
      c("Unique Sites", "Shannon Index", 
        "Gini Index", "Chao(1) est.", 
        "UC50", "Percent in Txn Units", 
        "Percent in Same Orientation", "Percent Near Txn Units", 
        "Percent in Onco-related Txn Unit", "Estimated Abundance", 
        "Relative Abundance", "RefSeq 10kb", 
        "RefSeq 100kb", "RefSeq 1Mb", 
        "GC 100bp", "GC 1kb", "GC 10kb", "GC 100kb", "GC 1Mb", 
        "CpG sites within 1kb", "CpG sites within 10kb", 
        "CpG Density 10kb", "CpG Density 100kb", "CpG Density 1Mb",
        "DNaseI sites within 1kb", "DNaseI sites within 10kb", 
        "DNaseI sites within 100kb", "DNaseI sites within 1Mb", 
        "Activated CD4+ HDAC6", "Activated CD4+ Tip60", 
        "Activated Nucleosomes", "Brd2 promoters", 
        "Brd3 promoters", "Brd4 promoters", "CTCF", 
        "H2AK5ac", "H2AK9ac", "H2AZ", "H2BK120ac", "H2BK12ac", "H2BK20ac", 
        "H2BK5ac", "H2BK5me1", "H3K14ac", "H3K18ac", "H3K23ac", "H3K27ac", 
        "H3K27me1", "H3K27me2", "H3K27me3", "H3K36ac", "H3K36me1", "H3K36me3", 
        "H3K4ac", "H3K4me1", "H3K4me2", "H3K4me3", "H3K79me1", "H3K79me2", 
        "H3K79me3", "H3K9ac", "H3K9me1", "H3K9me2", "H3K9me3", "H3R2me1", 
        "H3R2me2", "H4K12ac", "H4K16ac", "H4K20me1", "H4K20me3", "H4K5ac", 
        "H4K8ac", "H4K91ac", "H4R3me2", "HP1a promoters", "HP1b promoters", 
        "NRSF", "PolII", "Resting CD4+ CBP", "Resting CD4+ HDAC1", 
        "Resting CD4+ HDAC2", "Resting CD4+ HDAC3", "Resting CD4+ HDAC6", 
        "Resting CD4+ MOF", "Resting CD4+ p300", "Resting CD4+ PCAF", 
        "Resting CD4+ Tip60", "Resting Nucleosomes", 
        "Clusters Represented", "Sites in Clusters", "Abundance in Clusters"),
      names = all_features)
    
    grouped_features <- structure(
      c("numUniqSites", "estAbund", "relAbund", "ShannonIndex", "GiniIndex", 
        "Chao1", "UC50", "clustersRepresented", "numSitesInClusters",
        "abundInClusters", "pctTxnUnit", "pctSameOrt", "pctNearTxnUn", 
        "pctInOnco", "refSeq_counts.10k", "refSeq_counts.100k", 
        "refSeq_counts.1M", "GC.100", "GC.1k", "GC.10k", "GC.100k", "GC.1M",
        "CpG_counts.1k", "CpG_counts.10k", "CpG_density.10k", 
        "CpG_density.100k", "CpG_density.1M", "DNaseI_count.1k", 
        "DNaseI_count.10k", "DNaseI_count.100k", "DNaseI_count.1M",
        "Brd2_promoters.10k", "Brd3_promoters.10k", "Brd4_promoters.10k",
        "H2AK5ac.10k", "H2AK9ac.10k", "H2AZ.10k", "H2BK120ac.10k", 
        "H2BK12ac.10k", "H2BK20ac.10k", "H2BK5ac.10k", "H2BK5me1.10k", 
        "H3K14ac.10k", "H3K18ac.10k", "H3K23ac.10k", "H3K27ac.10k", 
        "H3K27me1.10k", "H3K27me2.10k", "H3K27me3.10k", "H3K36ac.10k", 
        "H3K36me1.10k", "H3K36me3.10k", "H3K4ac.10k", "H3K4me1.10k", 
        "H3K4me2.10k", "H3K4me3.10k", "H3K79me1.10k", "H3K79me2.10k", 
        "H3K79me3.10k", "H3K9ac.10k", "H3K9me1.10k", "H3K9me2.10k",
        "H3K9me3.10k", "H3R2me1.10k", "H3R2me2.10k", "H4K12ac.10k", 
        "H4K16ac.10k", "H4K20me1.10k", "H4K20me3.10k", "H4K5ac.10k", 
        "H4K8ac.10k", "H4K91ac.10k", "H4R3me2.10k", "CTCF.10k", "NRSF.10k",
        "PolII.10k", "HP1a_promoters.10k", "HP1b_promoters.10k", 
        "Act_CD4_HDAC6.10k", "Act_CD4_Tip60.10k", "ActivatedNucleosomes.10k", 
        "RestingNucleosomes.10k", "Rest_CD4_CBP.10k", "Rest_CD4_HDAC1.10k",
        "Rest_CD4_HDAC2.10k", "Rest_CD4_HDAC3.10k", "Rest_CD4_HDAC6.10k",
        "Rest_CD4_MOF.10k", "Rest_CD4_p300.10k", "Rest_CD4_PCAF.10k",
        "Rest_CD4_Tip60.10k"
      ),
      names = c(
        rep("Population", 10), rep("Genomic", 24), 
        rep("Epigenetic", 39), rep("Bound Proteins", 18)
      )
    )

  }
)
```

```{r fig5AB, fig.height=6, fig.width=10.25, out.width="80%"}
# Model contributions
model_analysis <- within(
  model_analysis, {
    
    min_pct <- 1.0
    
    wt_pca_cont_tdn <- tdn_pca$rotation 
    coef_lasso_tdn <- coef(tdn_min_model)
    coef_lasso_tdn <- coef_lasso_tdn[2:nrow(coef_lasso_tdn), , drop = FALSE]
    colnames(coef_lasso_tdn) <- "tdn"
    wt_tdn_mod_cont <- 
      wt_pca_cont_tdn[,seq_len(tdn_pca_cutoff)] %*% coef_lasso_tdn
    
    wt_pca_cont_d28 <- d28_pca$rotation 
    coef_lasso_d28 <- coef(d28_min_model)
    coef_lasso_d28 <- coef_lasso_d28[2:nrow(coef_lasso_d28), , drop = FALSE]
    colnames(coef_lasso_d28) <- "d28"
    wt_d28_mod_cont <- 
      wt_pca_cont_d28[,seq_len(d28_pca_cutoff)] %*% coef_lasso_d28
    
    compare_df <- cbind(wt_tdn_mod_cont, wt_d28_mod_cont) %>% as.matrix() %>%
      as.data.frame() %>%
      dplyr::mutate(
        vars = factor(row.names(.), levels = rev(colnames(tdn_mat))),
        tdn_pct = 100 * tdn**2 / sum(tdn**2),
        tdn_pct = ifelse(tdn > 0, tdn_pct, -tdn_pct),
        d28_pct = 100 * d28**2 / sum(d28**2),
        d28_pct = ifelse(d28 > 0, d28_pct, -d28_pct)) %>%
      dplyr::select(vars, tdn_pct, d28_pct) %>%
      dplyr::arrange(vars) %>%
      tidyr::gather("mod", "pct", -vars) %>%
      dplyr::mutate(
        mod = str_remove(mod, "_pct"),
        mod = gsub("tdn", "TDN Product", mod),
        mod = gsub("d28", "Day 28", mod),
        mod = factor(mod, levels = c("TDN Product", "Day 28")),
        pct = -pct,
        effect = ifelse(pct > 0, "pos", "neg"),
        var_grp = names(grouped_features)[match(vars, grouped_features)],
        var_grp = factor(var_grp, levels = unique(names(grouped_features)))) %>%
      dplyr::arrange(mod, var_grp, desc(pct))
    
    tdn_grp_levels <- compare_df %>%
      dplyr::filter(mod == "TDN Product") %>%
      dplyr::arrange(var_grp, desc(pct)) %$%
      unique(as.character(vars))
    
    d28_grp_levels <- compare_df %>%
      dplyr::filter(mod == "Day 28") %>%
      dplyr::arrange(var_grp, desc(pct)) %$%
      unique(as.character(vars))
      
    facet_plot <- compare_df %>%
      dplyr::filter(abs(pct) >= min_pct) %>%
      dplyr::group_by(vars) %>%
      dplyr::mutate(same_dir = n() > 1 & (all(pct > 0) | all(pct < 0))) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(
        vars = factor(
          format_features[as.character(vars)],
          levels = rev(format_features[tdn_grp_levels]))) %>%
      dplyr::arrange(vars) %>%
      ggplot(aes(x = vars, y = pct)) + 
      geom_hline(yintercept = 0, color = "grey75") +
      geom_bar(stat = "identity", color = "black", fill = "black") + 
      facet_grid(var_grp ~ mod, scales = "free", space = "free") +
      scale_fill_brewer(palette = "Set1", direction = -1) +
      lims(y = c(-15, 15)) +
      coord_flip() +
      labs(
        x = NULL,
        y = "Percent Contribution to Models\n(Positive towards Response)") +
      theme(
        strip.text.y = element_text(angle = 0),
        panel.grid.major.y = element_line(
          color = "grey75", linetype = "dotted"),
        legend.position = "none",
        axis.text.y = element_text(size = 9))
    
    #facet_plot
    
    # Extra plots
    tdn_contrib_plot <- compare_df %>%
      dplyr::filter(abs(pct) >= min_pct) %>%
      dplyr::group_by(vars) %>%
      dplyr::mutate(same_dir = n() > 1 & (all(pct > 0) | all(pct < 0))) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(vars = factor(
        format_features[as.character(vars)],
        levels = rev(format_features[tdn_grp_levels]))) %>%
      dplyr::filter(mod == "TDN Product") %>%
      ggplot(aes(x = vars, y = pct)) + 
      geom_hline(yintercept = 0, color = "grey75") +
      geom_bar(stat = "identity", color = "black", fill = "black") + 
      facet_grid(var_grp ~ ., scale = "free", space = "free") +
      scale_y_continuous(limits = c(-15, 15)) +
      coord_flip() +
      labs(
        x = NULL,
        y = "Percent Contribution to Model\n<---     ---->\nPR/NR    CR/PRtd",
        title = "Transduction Products"
      ) +
      theme(
        panel.grid.major.y = element_line(
          color = "grey75", linetype = "dotted"),
        legend.position = "none",
        axis.text.y = element_text(size = 9),
        strip.text.y = element_text(angle = 0)
      )
    
    d28_contrib_plot <- compare_df %>%
      dplyr::filter(abs(pct) >= min_pct) %>%
      dplyr::group_by(vars) %>%
      dplyr::mutate(same_dir = n() > 1 & (all(pct > 0) | all(pct < 0))) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(vars = factor(
        format_features[as.character(vars)],
        levels = rev(format_features[d28_grp_levels]))) %>%
      dplyr::filter(mod == "Day 28") %>%
      ggplot(aes(x = vars, y = pct)) + 
      geom_hline(yintercept = 0, color = "grey75") +
      geom_bar(stat = "identity", color = "black", fill = "black") + 
      facet_grid(var_grp ~ ., scale = "free", space = "free") +
      scale_y_continuous(limits = c(-15, 15)) +
      coord_flip() +
      labs(
        x = NULL,
        y = "Percent Contribution to Model\n<---     ---->\nPR/NR    CR/PRtd",
        title = "Day 28 Samples"
      ) +
      theme(
        panel.grid.major.y = element_line(
          color = "grey75", linetype = "dotted"),
        legend.position = "none",
        axis.text.y = element_text(size = 9),
        strip.text.y = element_text(angle = 0)
      )
})

grid.arrange(
  grobs = list(
    model_analysis$tdn_contrib_plot, model_analysis$d28_contrib_plot),
  nrow = 1)
```
Figure 5. Predicting clinical outcome from integration site data. A total of 91 features spanning population metrics, genomic features, and epigenetic features from 29 patients were used in least absolute shrinkage and selection operator (LASSO) logistic regression to build a classification model. Results from leave-one-out cross-validation of models based on transduction/pre-infusion products (A) and day 28 peripherial blood samples (B). Bar plots indicate the contribution of different features to classification in each model. Positive values indicate correlation with a positive clinical outcome while negative contributions indicate a correlation with negative clinical outcomes. 

\newpage
```{r fig5C, fig.height=3, fig.width=3}
gen_express <- within(
  list(), {
    
    patient_tdn_specimens <- model_analysis$patient_tdn_specimens
    select_patients <- patient_tdn_specimens$patient
    select_response <- patient_tdn_specimens$determinant_response
    
    # Load baseline txn ----
    txn_mock_stim <- data.table::fread(
        input = file.path(
          outputDir, "fraietta_et_al_2018_data", 
          "cart19_transcript_assay_mockstim.csv"
        ), 
        sep = ",", header = TRUE, data.table = FALSE
      ) %>% 
      dplyr::rename("symbol" = Patient_ID)
    
    txn_mock_stim_mat <- as.matrix(txn_mock_stim[,2:ncol(txn_mock_stim)])
    
    rownames(txn_mock_stim_mat) <- alias_arbiter(
      IDs = txn_mock_stim$symbol, RefIDs = hgnc_complete$symbol,
      aliasIDs = hgnc_complete$extended_alias, sep = "|", 
      remove_absent_IDs = NULL, quiet = TRUE
    )
    
    txn_mock_stim_mat <- do.call(rbind, lapply(
      split(as.data.frame(txn_mock_stim_mat), rownames(txn_mock_stim_mat)), 
      function(x) apply(x, 2, sum)
    ))
    
    # Load stimulated txn ----
    txn_exp_stim <- data.table::fread(
        input = file.path(
          outputDir, "fraietta_et_al_2018_data", 
          "cart19_transcript_assay_stimulated.csv"
        ), 
        sep = ",", header = TRUE, data.table = FALSE
      ) %>%
      dplyr::rename("symbol" = Patient_ID)
    
    txn_exp_stim_mat <- as.matrix(txn_exp_stim[,2:ncol(txn_exp_stim)])
    
    rownames(txn_exp_stim_mat) <- alias_arbiter(
      IDs = txn_exp_stim$symbol, RefIDs = hgnc_complete$symbol,
      aliasIDs = hgnc_complete$extended_alias, sep = "|", 
      remove_absent_IDs = NULL, quiet = TRUE
    )
    
    txn_exp_stim_mat <- do.call(rbind, lapply(
      split(as.data.frame(txn_exp_stim_mat), rownames(txn_exp_stim_mat)), 
      function(x) apply(x, 2, sum)
    ))
    
    # Normalize patients between model development and expression data ----
    keep_pats_idx <- which(select_patients %in% colnames(txn_exp_stim_mat))
    select_patients <- select_patients[keep_pats_idx]
    select_response <- select_response[keep_pats_idx]
    
    # Normalized data to read density (R/K/M) ----
    txn_mock_stim_mat <- apply(
      txn_mock_stim_mat, 2, function(x) (x/1000)/(sum(x)/1E6)
    )
    
    txn_exp_stim_mat <- apply(
      txn_exp_stim_mat, 2, function(x) (x/1000)/(sum(x)/1E6)
    )
    
    keep_genes <- apply(
      cbind(txn_mock_stim_mat, txn_exp_stim_mat), 
      1, function(x) all(x != 0)
    )
    
    txn_mock_stim_mat <- txn_mock_stim_mat[keep_genes,]
    txn_exp_stim_mat <- txn_exp_stim_mat[keep_genes,]
    
    txn_stim_mat <- txn_exp_stim_mat - txn_mock_stim_mat
    
    txn_exp_v_mock <- data.frame(
      symbol = rownames(txn_mock_stim_mat),
      mock = apply(log10(txn_mock_stim_mat), 1, mean),
      exp = apply(log10(txn_exp_stim_mat), 1, mean),
      wilcox = apply(cbind(txn_mock_stim_mat, txn_exp_stim_mat), 1, function(x){
        
        z <- wilcox.test(
          x = x[seq_len(ncol(txn_mock_stim_mat))], 
          y = x[(ncol(txn_mock_stim_mat)+1):(2*ncol(txn_mock_stim_mat))])
        
        z$p.value
        
      }), 
      row.names = NULL
    )
    
    txn_mock_pca <- prcomp(
      t(txn_mock_stim_mat[,select_patients]), scale. = TRUE
    )
    
    txn_exp_pca <- prcomp(
      t(txn_exp_stim_mat[,select_patients]), scale. = TRUE
    )
    
    txn_stim_pca <- prcomp(
      t(txn_stim_mat[,select_patients]), scale. = TRUE
    )
    
    mock_plot <- plot_mva(D = txn_mock_pca$x, cl = select_response) +
      labs(
        x = paste0(
          "PC1 (", 
          round(100*summary(txn_mock_pca)$importance[2,1], digits = 1), 
          "%)"
        ),
        y = paste0(
          "PC2 (", 
          round(100*summary(txn_mock_pca)$importance[2,2], digits = 1), 
          "%)"
        ),
        title = "A. Absolute mock stimulated expression"
      ) + 
      base_theme
    
    exp_plot <- plot_mva(D = txn_exp_pca$x, cl = select_response) +
      labs(
        x = paste0(
          "PC1 (", 
          round(100*summary(txn_exp_pca)$importance[2,1], digits = 1), 
          "%)"
        ),
        y = paste0(
          "PC2 (", 
          round(100*summary(txn_exp_pca)$importance[2,2], digits = 1), 
          "%)"
        ),
        title = "B. Absolute stimulated expression"
      ) + 
      base_theme
    
    stim_plot <- plot_mva(D = txn_stim_pca$x, cl = select_response) +
      labs(
        x = paste0(
          "PC1 (", 
          round(100*summary(txn_stim_pca)$importance[2,1], digits = 1), 
          "%)"
        ),
        y = paste0(
          "PC2 (", 
          round(100*summary(txn_stim_pca)$importance[2,2], digits = 1), 
          "%)"
        ),
        title = "C. Differential stimulated expression"
      ) + 
      base_theme
    
    #pca_plots <- grid.arrange(
    #  grobs = list(mock_plot, exp_plot, stim_plot), ncol = 1
    #)
    
    t.test(
      x = split(txn_mock_pca$x[, 1], select_response)[[1]],
      y = split(txn_mock_pca$x[, 1], select_response)[[2]]
    )
    
    wilcox.test(
      x = split(txn_exp_pca$x[, 1], select_response)[[1]],
      y = split(txn_exp_pca$x[, 1], select_response)[[2]]
    )
    
    t.test(
      x = split(txn_stim_pca$x[, 1], select_response)[[1]],
      y = split(txn_stim_pca$x[, 1], select_response)[[2]]
    )

    # Select patients and gene data ----
    pats <- dplyr::intersect(std_clin_patients, colnames(txn_exp_stim_mat))
    
    pat_tdn_mat <- tdn_sites %>%
      as.data.frame(row.names = NULL) %>%
      dplyr::filter( patient %in% pats ) %>%
      dplyr::filter( in_gene != FALSE | abs(nearest_geneDist) <= 5000 ) %>%
      dplyr::left_join(patient_data, by = "patient") %>%
      dplyr::select(
        determinant_response, patient, posid, gene_id_wo_annot
      ) %>%
      dplyr::mutate(total_sites = n_distinct(patient, posid)) %>%
      dplyr::group_by(determinant_response, patient) %>%
      dplyr::mutate(pat_sites = n_distinct(patient, posid)) %>%
      dplyr::group_by(determinant_response) %>%
      dplyr::mutate(grp_sites = n_distinct(patient, posid)) %>%
      dplyr::group_by(
        determinant_response, patient, gene_id_wo_annot, 
        total_sites, grp_sites, pat_sites
      ) %>%
      dplyr::summarise(sites = dplyr::n_distinct(patient, posid)) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(pat_pct = sites / pat_sites)
    
    all_tdn_mat <- pat_tdn_mat %>%
      dplyr::group_by(
        determinant_response, gene_id_wo_annot, total_sites, grp_sites
      ) %>%
      dplyr::summarise(sites = sum(sites)) %>%
      dplyr::ungroup() %>%
      tidyr::spread(key = determinant_response, value = sites, fill = 0) %>%
      dplyr::mutate(
        CR_pct = CR_PRtd / grp_sites,
        NR_pct = PR_NR / grp_sites,
        Tot_pct = (CR_PRtd + PR_NR) / total_sites
      ) %>% 
      dplyr::group_by(gene_id_wo_annot) %>%
      dplyr::summarise(
        CR_pct = sum(CR_pct), NR_pct = sum(NR_pct), Tot_pct = sum(Tot_pct)
      ) %>%
      dplyr::ungroup() %>%
      as.data.frame()
    
    row.names(all_tdn_mat) <- all_tdn_mat$gene_id_wo_annot
    
    all_tdn_mat <- as.matrix(all_tdn_mat[,2:ncol(all_tdn_mat)])

    resp <- patient_tdn_specimens$determinant_response[
      match(pats, patient_tdn_specimens$patient)
    ]
    
    genes <- dplyr::intersect(rownames(all_tdn_mat), rownames(txn_exp_stim_mat))
    
    mean_txn_exp_mat <- do.call(cbind, lapply(unique(resp), function(r){
      mat <- txn_exp_stim_mat[, pats %in% pats[resp == r]]
      apply(mat, 1, mean)
    }))
    
    colnames(mean_txn_exp_mat) <- unique(resp)
    mean_txn_exp_mat <- mean_txn_exp_mat[genes,]
    
    stim_txn_mat <- do.call(cbind, lapply(unique(resp), function(r){
      mat <- txn_stim_mat[, pats %in% pats[resp == r]]
      apply(mat, 1, mean)
    }))
    
    colnames(stim_txn_mat) <- unique(resp)
    stim_txn_mat <- stim_txn_mat[genes,]
    
    # Determine Rank orders for gene expression ----
    grp_cnt <- 10
    
    total_gene_txn_order <- apply(mean_txn_exp_mat, 1, mean) %>%
      data.frame(txn_lvl = .) %>%
      dplyr::mutate(gene = row.names(.)) %>%
      dplyr::arrange(txn_lvl) %>%
      dplyr::mutate(
        rank_ord = seq_len(n()),
        rank_grp = ceiling(rank_ord / (n() / grp_cnt)),
        CR_pct = all_tdn_mat[gene, "CR_pct"],
        NR_pct = all_tdn_mat[gene, "NR_pct"],
        Tot_pct = all_tdn_mat[gene, "Tot_pct"]
      )

    CR_gene_txn_order <- mean_txn_exp_mat[, "CR_PRtd"] %>%
      data.frame(txn_lvl = .) %>%
      dplyr::mutate(gene = row.names(.)) %>%
      dplyr::arrange(txn_lvl) %>%
      dplyr::mutate(
        rank_ord = seq_len(n()),
        rank_grp = ceiling(rank_ord / (n() / grp_cnt)),
        CR_pct = all_tdn_mat[gene, "CR_pct"],
        NR_pct = all_tdn_mat[gene, "NR_pct"],
        Tot_pct = all_tdn_mat[gene, "Tot_pct"]
      )

    NR_gene_txn_order <- mean_txn_exp_mat[, "PR_NR"] %>%
      data.frame(txn_lvl = .) %>%
      dplyr::mutate(gene = row.names(.)) %>%
      dplyr::arrange(txn_lvl) %>%
      dplyr::mutate(
        rank_ord = seq_len(n()),
        rank_grp = ceiling(rank_ord / (n() / grp_cnt)),
        CR_pct = all_tdn_mat[gene, "CR_pct"],
        NR_pct = all_tdn_mat[gene, "NR_pct"],
        Tot_pct = all_tdn_mat[gene, "Tot_pct"]
      )

    
    stim_gene_txn_order <- apply(stim_txn_mat, 1, mean) %>%
      data.frame(txn_lvl = .) %>%
      dplyr::mutate(gene = row.names(.)) %>%
      dplyr::arrange(txn_lvl) %>%
      dplyr::mutate(
        rank_ord = seq_len(n()),
        rank_grp = ceiling(rank_ord / (n() / grp_cnt)),
        CR_pct = all_tdn_mat[gene, "CR_pct"],
        NR_pct = all_tdn_mat[gene, "NR_pct"],
        Tot_pct = all_tdn_mat[gene, "Tot_pct"]
      )
    
    diff_gene_txn_order <- apply(stim_txn_mat, 1, diff) %>%
      data.frame(txn_lvl = .) %>%
      dplyr::mutate(
        gene = row.names(.)
      ) %>%
      dplyr::arrange(txn_lvl) %>%
      dplyr::mutate(
        rank_ord = seq_len(n()),
        rank_grp = ceiling(rank_ord / (n() / grp_cnt)),
        CR_pct = all_tdn_mat[gene, "CR_pct"],
        NR_pct = all_tdn_mat[gene, "NR_pct"],
        Tot_pct = all_tdn_mat[gene, "Tot_pct"]
      )
    
    keep_cnt <- 500
    
    grp_diff_genes <- diff_gene_txn_order %>%
      dplyr::filter(rank_ord <= keep_cnt | rank_ord >= n()-keep_cnt) %>%
      dplyr::mutate(
        preference = ifelse(rank_ord <= keep_cnt, "NR favored", "CR favored")
      ) %$%
      structure(gene, names = preference)
    
    diff_gene_txn_order %>%
      dplyr::filter(gene %in% grp_diff_genes) %>%
      dplyr::mutate(
        preference = factor(
          names(grp_diff_genes)[match(gene, grp_diff_genes)], 
          levels = c("NR favored", "CR favored")
        )
      ) %>%
      dplyr::group_by(preference) %>%
      dplyr::summarise(
        CR_pct = sum(CR_pct),
        NR_pct = sum(NR_pct)
      ) %>%
      dplyr::ungroup() %>%
      tidyr::gather(key = "resp", value = "pct", -preference) %>% 
      ggplot(aes(x = resp, y = pct)) +
      geom_bar(stat = "identity") +
      facet_grid(. ~ preference, scales = "free") +
      custom_theme

    pat_spec_grp_data <- pat_tdn_mat %>%
      dplyr::rename(
        gene = gene_id_wo_annot,
        resp = determinant_response
      ) %>%
      dplyr::filter(gene %in% grp_diff_genes) %>%
      dplyr::mutate(
        preference = factor(
          names(grp_diff_genes)[match(gene, grp_diff_genes)],
          levels = c("NR favored", "CR favored")
        ),
        resp = factor(
          gsub("_", "/", resp), levels = c("PR/NR", "CR/PRtd")
        )
      ) %>%
      dplyr::group_by(resp, patient, preference) %>%
      dplyr::summarise(pct = sum(pat_pct)) %>%
      dplyr::ungroup() %>%
      dplyr::filter(preference == "CR favored")
    
    pat_spec_sig_test <- pat_spec_grp_data %>%
      dplyr::group_by(preference) %>%
      dplyr::summarise(
        sig = wilcox.test(pct ~ resp)$p.value
      )
    
    pct_intsites_by_grp_plot <- ggplot() +
      geom_boxplot(
        data = pat_spec_grp_data, 
        aes(x = resp, y = pct * 100, fill = resp), 
        outlier.alpha = 0
      ) +
      geom_text(
        data = pat_spec_sig_test, 
        aes(
          x = rep(1.5, nrow(pat_spec_sig_test)),
          y = rep(10, nrow(pat_spec_sig_test)),
          label = sprintf("p-value = %.3f", round(sig, digits = 3))
        )
      ) +
      scale_fill_brewer(type = "qual", palette = "Set1") +
      labs(
        x = "Patient Response Groups", 
        y = "Percent of Integration Sites",
        title = "C."
      ) +
      custom_theme + 
      theme(
        legend.position = "none",
        axis.line = element_line(color = "black"),
        axis.text.x = element_text(face = "bold"),
        plot.title = element_text(color = "black", size = 12, face = "bold")
      )
      
    total_gene_exp_plot <- total_gene_txn_order %>%
      dplyr::group_by(rank_grp) %>%
      dplyr::summarise(CR = sum(CR_pct), NR = sum(NR_pct)) %>%
      tidyr::gather(key = "type", value = "pct", -rank_grp) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(
        type = factor(
          ifelse(type == "CR", "CR/PRtd", "PR/NR"), 
          levels = c("PR/NR", "CR/PRtd")
        )
      ) %>%
      ggplot(aes(x = rank_grp, y = pct * 100, color = type)) +
      geom_point() + 
      geom_line(alpha = 0.25) +
      facet_wrap(type ~ ., ncol = 1, scales = "free_x") +
      scale_x_continuous(breaks = 1:10, labels = 1:10) +
      scale_color_brewer(type = "qual", palette = "Set1") +
      labs(
        x = "Stimulated Expression Rank Groups", 
        y = "Percent of Integration Sites",
        color = NULL
      ) +
      custom_theme + 
      theme(
        legend.position = "none",
        axis.line = element_line(color = "black"),
        plot.title = element_text(color = "black", size = 12, face = "bold")
      )
    
    criteria_palette <- structure(
      colorRampPalette(RColorBrewer::brewer.pal(11, "Spectral"))(
        n = length(unique(goi_data$Criteria))
      ),
      names = sort(unique(goi_data$Criteria))
    )
    
    goi_total_rank_plot <- total_gene_txn_order %>% 
      dplyr::filter(gene %in% unlist(goi_lists)) %>%
      dplyr::arrange(rank_grp) %>%
      dplyr::mutate(
        criteria = goi_data$Criteria[match(gene, goi_data$Gene_Name)],
        rank_grp = factor(rank_grp, levels = unique(rank_grp))
      ) %>%
      ggplot(aes(x = rank_grp)) +
      geom_bar(aes(fill = criteria)) +
      scale_fill_manual(values = criteria_palette) +
      labs(
        x = "Stimulated Expression Rank Groups",
        y = "Gene Count",
        fill = "Criteria"
      ) +
      custom_theme
  
  }
)

gen_express$pct_intsites_by_grp_plot

```
Figure 5. (C) Vector integration in the CR/PRtd sample is favored in transcription units preferentially active in the T-cells from CR/PRtd. RNA-seq data were analyzed to identify the top 500 genes that were preferentially active in pre-infusion products from CR/PRtd versus PR/NR. The frequency of integration in these genes (y-axis) was then compared between integration sites from CR/PRtd versus PR/NR (x-axis). 

\newpage
# Supplemental Materials
```{r add_investigations}
add_investigations <- within(
  list(), {

    set.seed(1)
    # Memory subset abundance by disease and response groups ----
    add_pat_data <- read.csv(
        file.path(outputDir, "additional_patient_data.csv")
      ) %>%
      dplyr::select(-Patient_Code, -Disease)
    
    tdn_metrics <- summaries$specimen %>%
      dplyr::filter(
        celltype == "Tcells" & 
          timepoint == "d0" & 
          patient %in% std_clin_patients
      ) %>%
      dplyr::left_join(add_pat_data, by = c("patient" = "Patient_ID")) %>%
      dplyr::mutate(
        determinant_response = gsub("_", "/", determinant_response),
        determinant_response = factor(
          determinant_response, levels = c("PR/NR", "CR/PRtd")
        ),
        rel_disease = factor(
          ifelse(disease == "CLL", "CLL", "ALL"),
          levels = c("ALL", "CLL")
        )
      )
    
    mem_t_test <- dplyr::select(
        tdn_metrics, rel_disease, determinant_response, 
        "mem_pct" = pct_CD8posCCR7posCD45ROpos_Tcell_Frequency_at_Apheresis_by_pretransduction
      ) %>%
      dplyr::group_by(rel_disease) %>%
      dplyr::summarise(p_value = t.test(mem_pct ~ determinant_response)$p.value)
    
    mem_subsets_plot <- ggplot(
        tdn_metrics, 
        aes(
          x = determinant_response, 
          y = pct_CD8posCCR7posCD45ROpos_Tcell_Frequency_at_Apheresis_by_pretransduction
        )
      ) +
      stat_summary(fun.data = "mean_cl_boot", geom = "crossbar", color = "black") +
      geom_point(
        aes(shape = disease, fill = determinant_response), 
        position = position_jitter(width = 0.25),
        size = 2.5
      ) +
      facet_grid(. ~ rel_disease) +
      labs(
        shape = "Disease", fill = "Response", 
        x = NULL, y = "% Central Memory within Infusion Product"
      ) + 
      scale_fill_brewer(palette = "Set1") +
      scale_shape_manual(values = c(25, 24, 21)) +
      guides(fill = guide_legend(override.aes = aes(shape = 22, size = 3))) +
      custom_theme +
      theme(
        strip.background = element_rect(color = "black"),
        axis.line = element_line(color = "black")
      )
    
    # Test for disease specific differences within the data sets ----
    # code here is condensed, for comments see model_analysis section
    center_scale <- function(input, trn = NULL){
      if(is.null(trn)) trn <- input
      means <- apply(trn, 2, mean)
      stdevs <- apply(trn, 2, sd)
      t(apply(input, 1, function(x) (x - means) / stdevs))
    }

    
    tdn_data <- tdn_metrics %>%
      dplyr::filter(patient %in% std_clin_patients) %>%
      dplyr::select(
        patient, rel_disease, everything(), -trial, -celltype, -timepoint, 
        -Age_at_CAR_Tcell_Infusion, -pct_CAR_Tcell_Frequency_in_Infusion_Product,
        -pct_CD8posCCR7posCD45ROpos_Tcell_Frequency_at_Apheresis_by_pretransduction
      )
    
    tdn_mat <- as.matrix(
      tdn_data[,(which(names(tdn_data) == "specimen")+1):ncol(tdn_data)]
    )
    
    rownames(tdn_mat) <- tdn_data$patient

    ## Patient and response vectors ----
    pats_tdn <- tdn_data$patient
    disease_tdn <- tdn_data$rel_disease
    vars <- colnames(tdn_mat)
    
    ## Dimensional reduction ----
    tdn_scaled <- center_scale(tdn_mat)
    tdn_pca <- prcomp(x = tdn_scaled, retx = TRUE, scale. = FALSE)
    tdn_trans <- predict(tdn_pca, tdn_scaled)
    
    ## Generate LASSO models ----
    tdn_pca_cutoff <- data.frame(
        component = 2:ncol(tdn_trans),
        misclass = sapply(2:ncol(tdn_trans), function(cutoff){
          
          cv <- cv.glmnet(
            x = tdn_trans[, seq_len(cutoff), drop = FALSE], y = disease_tdn, 
            family = "binomial", type.measure = "class", 
            nfold = nrow(tdn_trans), grouped = FALSE, parallel = TRUE
          )
          
          cv$cvm[match(cv$lambda.min, cv$lambda)]
          
        })) %>%
      dplyr::filter(misclass == min(misclass)) %>%
      dplyr::filter(component == min(component)) %$%
      component

    cv_tdn_pca <- cv.glmnet(
      x = tdn_trans[,seq_len(tdn_pca_cutoff)], y = disease_tdn, 
      family = "binomial", alpha = 1, type.measure = "class", 
      nfold = nrow(tdn_trans), grouped = FALSE, parallel = TRUE, keep = TRUE
    )
    
    tdn_min_model <- glmnet(
      x = tdn_trans[,seq_len(tdn_pca_cutoff)], y = disease_tdn, 
      family = "binomial", alpha = 1, lambda = cv_tdn_pca$lambda.min
    )
    
    disease_lasso_contrib_plot <- tdn_pca$rotation[,seq_len(tdn_pca_cutoff)] %*% 
      tdn_min_model$beta %>%
      as.matrix %>% as.data.frame() %>%
      dplyr::mutate(
        factors = factor(
          row.names(.), levels = model_analysis$grouped_features
        ),
        factor_grps = names(model_analysis$grouped_features)[
          match(as.character(factors), model_analysis$grouped_features)
        ],
        factor_grps = factor(
          factor_grps, levels = unique(names(model_analysis$grouped_features))
        ),
        contrib = - 100 * s0 * abs(s0) / sum(s0**2)
      ) %>%
      dplyr::filter(abs(contrib) >= 1) %>%
      ggplot(aes(x = factors, y = contrib)) +
      geom_hline(yintercept = 0, color = "grey70") +
      geom_col(fill = "black", color = "black") +
      coord_flip() +
      facet_grid(factor_grps ~ ., scales = "free", space = "free") +
      #scale_fill_brewer(palette = "Set1") +
      scale_x_discrete(labels = model_analysis$format_features) +
      scale_y_continuous(
        breaks = c(-8, -6, -4, -2, 0, 2, 4), labels = c(8, 6, 4, 2, 0, 2, 4)
      ) +
      labs(
        y = "Variance Explained (%)\n CLL <------> ALL", 
        x = "Measurements"
      ) +
      custom_theme +
      theme(
        legend.position = "none",
        panel.grid.major.y = element_line(
          color = "grey75", linetype = "dotted"),
        strip.text.y = element_text(angle = 0),
        strip.background = element_rect(color = "black")
      )
  
    # Test for saturation / undersampling within the integration sites ----
    ## Functions to help with calculations
    jackIID <- function(ids, jrep = NULL, nrep = 10L){
      
      if( is.null(jrep) ) jrep <- sample(rep(seq_len(nrep), length = length(ids)))
      
      est0 <- vegan::estimateR(table(ids))
      jackrep <- jrep
      urepl <- unique(jrep)
      
      jackmat <- sapply(
        urepl, function(x) vegan::estimateR(table(ids[jackrep!=x]))
      )
      
      pseudo <- length(urepl) * est0 - (length(urepl)-1) * jackmat
      rowMeans(pseudo)
    }
    
    #' jackknife biased or unbiased Chao estimator
    #'
    #' @param replicatedSites df with column posid
    #' @return number population size estimate
    calculateChao <- function(ids, biased=TRUE){
      if ( !biased ) { #regular Chao
        cluster.tab <- table(ids)
        return(round(vegan::estimateR(cluster.tab)["S.chao1"]))
      }
      round(jackIID(ids)["S.chao1"])
    }
    
    specimen_sampling_data <- cond_uniq_sites %>%
      as.data.frame(row.names = NULL) %>%
      dplyr::group_by(specimen) %>%
      dplyr::summarise(
        sites = dplyr::n_distinct(posid),
        chao1 = calculateChao(rep(posid, estAbund), biased = sites >= 10),
        saturation = 100 * sites / max(c(chao1, sites))
      ) %>%
      dplyr::left_join(specimen_data, by = c("specimen" = "specimenaccnum")) %>%
      dplyr::left_join(patient_data, by = "patient") %>%
      dplyr::select(
        patient, disease, determinant_response, specimen, celltype, timepoint, 
        sites, chao1, saturation
      ) %>%
      dplyr::filter(
        timepoint %in% c("d0", "d28") & patient %in% std_clin_patients
      ) %>%
      dplyr::mutate(
        determinant_response = gsub("_", "/", determinant_response),
        determinant_response = factor(
          determinant_response, levels = c("PR/NR", "CR/PRtd")
        ),
        rel_disease = factor(
          ifelse(disease == "CLL", "CLL", "ALL"),
          levels = c("ALL", "CLL")
        )
      ) %>%
      dplyr::select(
        patient, disease, rel_disease, determinant_response, specimen, celltype, 
        timepoint, sites, chao1, saturation
      ) %>%
      dplyr::mutate(
        timepoint = factor(ifelse(
            as.character(timepoint) == "d0", "Infusion\nProduct", "Day 28"
          ), levels = c("Infusion\nProduct", "Day 28")
        ),
        grp = factor(paste0(
          as.character(rel_disease), "-", as.character(timepoint)
        ))
      )
    
    sampling_wilcox <- specimen_sampling_data %>%
      dplyr::group_by(timepoint) %>%
      dplyr::summarise(
        p.value = wilcox.test(saturation ~ rel_disease, exact = FALSE)$p.value
      )
    
    sampling_plot <- specimen_sampling_data %>%
      ggplot(aes(x = timepoint, y = saturation)) +
      stat_summary(fun.data = "mean_cl_boot", geom = "crossbar") +
      geom_point(
        aes(shape = disease, fill = determinant_response),
        size = 2, color = "black", 
        position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.9)
      ) +
      scale_fill_brewer(palette = "Set1") +
      scale_shape_manual(values = c(25, 24, 21)) +
      facet_grid(. ~ rel_disease) +
      labs(
        x = NULL, y = "Sampling Saturation (%)", 
        shape = "Disease", fill = "Response"
      ) +
      guides(fill = guide_legend(override.aes = aes(
        shape = 22, size = 4, color = "black"
      ))) +
      custom_theme +
      theme(
        axis.line = element_line(color = "black"),
        strip.background = element_rect(color = "black")
      )
    
    # Enrichment for cancer-associated genes ----
    ## Xie, M. et al. 2014 Nat. Med. "Age-related mutations associated with 
    ## clonal hematopoietic expansion and malignancies", supplmental table 7 & 8
    TCGA_list <- read.csv(
        file.path(utilsDir, "Xie_et_al.2014_Nat_Med_SupTbl7.csv")
      ) %>%
      dplyr::mutate(
        gene_name = alias_arbiter(
          IDs = Gene_Name,
          RefIDs = hgnc_complete$symbol,
          aliasIDs = hgnc_complete$extended_alias,
          sep = "|", remove_absent_IDs = NULL, quiet = TRUE)
      ) %$%
      gene_name
    
    clonal_hema_list <- c(
        "ASXL1", "ATM", "AXL", "BCORL1", "CBL", "CDKN2A", "CREBBP", "DIDO1", 
        "DNMT3A", "GNAS", "GUCY1A2", "HDAC4", "IDH2", "JAK2", "MBD1", "MECOM",
        "MYLK", "NOTCH3", "PPM1D", "PRKDC", "RICTOR", "SETBP1", "SF1", 
        "SF3B1", "SH2B3", "SNX25", "SOS1", "TET2", "TP53", "ZRSR2"
      ) %>%
      alias_arbiter(
        IDs = .,
        RefIDs = hgnc_complete$symbol,
        aliasIDs = hgnc_complete$extended_alias,
        sep = "|", remove_absent_IDs = NULL, quiet = TRUE
      )
    
    reference_gene_lists <- list(
      "allOnco (v3, 2017)" = oncoGenes,
      "TSGene (v2, 2016)" = tum_sups,
      "humanLymph" = badActors,
      "COSMIC-CGC (v89)" = cosmic_genes,
      "TCGA List" = TCGA_list,
      "Clonal Hema." = clonal_hema_list
    )
    
    shrt_list_names <- stringr::str_extract(
        names(reference_gene_lists), "[\\w\\ \\.\\-]+"
      ) %>%
      stringr::str_trim()
    
    ovlpmat_gene_lists <- sapply(reference_gene_lists, function(x){
      sapply(reference_gene_lists, function(y){
        sum( x %in% y )
      })
    })
    
    goi_lists$Composite <- unique(unlist(goi_lists[c(1,3,4)]))
    
    # random_list <- gene_impact$gene_name[
    #   sample.int(
    #     n = nrow(gene_impact), 
    #     size = length(unique(unlist(goi_lists))), 
    #     replace = FALSE
    #   )
    # ]
    
    ref_size <- length(unique(gene_impact$gene_name))
    
    ref_ovlp_cnt <- sapply(reference_gene_lists, function(x){
      sum(x %in% gene_impact$gene_name)
    })
    
    compare_gene_lists <- mapply(function(glist, ovlp_cnt){
        data.frame(
            criteria = names(goi_lists),
            size = sapply(goi_lists, length),
            ovlp = sapply(goi_lists, function(x){
              sum( glist %in% x )
            }),
            row.names = NULL
          ) %>%
          dplyr::mutate(
            p.value = sapply(seq_len(n()), function(i){
            
              fisher.test(
                matrix(
                  c(
                    ref_size - ovlp_cnt - size[i] + ovlp_cnt, 
                    size[i] - ovlp[i], 
                    ovlp_cnt - ovlp[i], 
                    ovlp[i]
                  ), 
                  ncol = 2
                ),
                alternative = "greater"
              )$p.value
            
            })
          )
        },
        glist = reference_gene_lists,
        ovlp_cnt = ref_ovlp_cnt,
        SIMPLIFY = FALSE
      ) %>%
      dplyr::bind_rows(.id = "List") %>%
      dplyr::group_by(criteria) %>%
      dplyr::mutate(
        sig = ifelse(p.value <= 0.05, "*", ""),
        adj.p.value = p.adjust(p.value, method = "BH"),
        adj.sig = ifelse(adj.p.value <= 0.05, "*", "")
      ) %>%
      dplyr::ungroup()
    
    compare_wide_frame <- compare_gene_lists %>%
      dplyr::mutate(
        print_val = paste0(
          format(round(adj.p.value, digits = 3)), " (", ovlp, ")", adj.sig
        ),
        print_val = format(print_val, justify = "left"),
        List = factor(List, levels = names(reference_gene_lists)),
        criteria = factor(criteria, levels = unique(criteria))
      ) %>%
      dplyr::select(List, criteria, size, print_val) %>%
      tidyr::spread(key = List, value = print_val)

  }
)
```

## Supplemental Figures

## Supplemental Figure 1. Favored integration in active transcription units.
```{r sup_fig_S01, fig.width=4, fig.height=3}
gen_express$total_gene_exp_plot
```
Figure S1. Favored integration in active transcription units. (Top) Favoring of integration in CR/PRtd in active transcription units. RNA-seq data was used to annotate gene activity (as reads per kilobase per million; RPKM), then genes were distributed into 10 bins with equal numbers of genes, ranked from lowest to highest RPKM (x-axis). Integration sites (fragments called by sonicAbundance) were then distributed into those bins and scored (y-axis). (Bottom) As in (Top), but using RNA-seq data and integration site data for PR/NR. RNA-seq data used in this study was from Fraietta et al., Nat. Med 24, 563-571, 2018.

\newpage
## Supplemental Figure 2. Overlap between expanded clones from infusion products and day 28 samples
```{r sup_fig_S02, fig.width=3, fig.height=3, out.width="50%"}
exp_clone_ovlp <- within(
  list(), {
    
    target_gene_number <- 50
    
    # Import objects from figure 2
    tdn_df <- intsite_clone_skew_plots$tdn_df
    d28_CR_PRtd <- intsite_clone_skew_plots$d28_CR_PRtd
    d28_PR_NR <- intsite_clone_skew_plots$d28_PR_NR
    
    # Define cutoffs
    cutoff_tdn <- head(tdn_df, n = target_gene_number) %$% min(estAbund)
    cutoff_d28_CR <- head(d28_CR_PRtd, n = target_gene_number) %$% min(estAbund)
    cutoff_d28_NR <- head(d28_PR_NR, n = target_gene_number) %$% min(estAbund)
    
    # Gene lists of clones from top X amount
    tdn_genes <- tdn_df %>%
      dplyr::filter(estAbund >= cutoff_tdn) %$%
      unique(gene_id_wo_annot)
    
    d28_CR_genes <- d28_CR_PRtd %>%
      dplyr::filter(estAbund >= cutoff_d28_CR) %$%
      unique(gene_id_wo_annot)

    d28_NR_genes <- d28_PR_NR %>%
      dplyr::filter(estAbund >= cutoff_d28_NR) %$%
      unique(gene_id_wo_annot)
    
    # Venn diagram of three populations
    futile.logger::flog.threshold(
      futile.logger::ERROR, name = "VennDiagramLogger"
    )
    
    VennDiagram::venn.diagram(
      list(
        "Infusion\nProducts" = tdn_genes, 
        "CR/PRtd" = d28_CR_genes, 
        "PR/NR" = d28_NR_genes
      ), 
      filename = file.path(
        workingDir, "reports", "manuscript_figures", "sup_fig_S5-1.png"
      ), 
      resolution = 300, height = 5, width = 5,  units = "in", imagetype = "png"
    )
    
    # Intersecting genes
    total_gene_cnt <- length(unique(c(
      tdn_df$gene_id_wo_annot, 
      d28_CR_PRtd$gene_id_wo_annot, 
      d28_PR_NR$gene_id_wo_annot
    )))
    
    tdn_only <- tdn_genes[!tdn_genes %in% c(d28_CR_genes, d28_NR_genes)]
    CR_only <- d28_CR_genes[!d28_CR_genes %in% c(tdn_genes, d28_NR_genes)]
    NR_only <- d28_NR_genes[!d28_NR_genes %in% c(tdn_genes, d28_CR_genes)]
    tdn_CR_xover <- intersect(tdn_genes, d28_CR_genes)
    tdn_NR_xover <- intersect(tdn_genes, d28_NR_genes)
    CR_NR_xover <- intersect(d28_CR_genes, d28_NR_genes)
    trip_xover <- vintersect(list(tdn_genes, d28_CR_genes, d28_NR_genes))
    
    # Fisher tests to see if this is significant overlap
    tcn_CR_test <- fisher.test(
      x = matrix(
        c(
          total_gene_cnt - length(union(tdn_genes, d28_CR_genes)),
          length(tdn_genes) - length(tdn_CR_xover),
          length(d28_CR_genes) - length(tdn_CR_xover),
          length(tdn_CR_xover)
        ),
        nrow = 2
      ),
      alternative = "greater"
    )

    tcn_NR_test <- fisher.test(
      x = matrix(
        c(
          total_gene_cnt - length(union(tdn_genes, d28_NR_genes)),
          length(tdn_genes) - length(tdn_NR_xover),
          length(d28_NR_genes) - length(tdn_NR_xover),
          length(tdn_NR_xover)
        ),
        nrow = 2
      ),
      alternative = "greater"
    )

    CR_NR_test <- fisher.test(
      x = matrix(
        c(
          total_gene_cnt - length(union(d28_CR_genes, d28_NR_genes)),
          length(d28_CR_genes) - length(CR_NR_xover),
          length(d28_NR_genes) - length(CR_NR_xover),
          length(CR_NR_xover)
        ),
        nrow = 2
      ),
      alternative = "greater"
    )
    
  }
)

include_graphics(path = file.path(
  workingDir, "reports", "manuscript_figures", "sup_fig_S5-1.png"
))
```
Figure S2. Assessment of genes shared by expanded clones from infusion products (TDN), day 28 samples from CR/PRtd, and day 28 samples from PR/NR patients. The top 50 clones were selected from each population (data from Figure 2 A-C). Genes associated with expanded clones only with TDN products: `r paste(exp_clone_ovlp$tdn_only, collapse = ", ")`. Genes associated only with day 28 products from CR/PRtd patients: `r paste(exp_clone_ovlp$CR_only, collapse = ", ")`. Genes associated only with day 28 products from PR/NR patients: `r paste(exp_clone_ovlp$NR_only, collapse = ", ")`. Genes associated with both TDN products and day 28 products from CR/PRtd patients: `r paste(exp_clone_ovlp$tdn_CR_xover, collapse = ", ")`. Genes associated with both TDN products and day 28 products from PR/NR patients: `r paste(exp_clone_ovlp$tdn_NR_xover, collapse = ", ")`. Genes associated with both CR/PRtd and PR/NR patients on day 28 samples: `r paste(exp_clone_ovlp$CR_NR_xover, collapse = ", ")`.

\newpage
## Supplemental Figure 3. Integration sites in cells undergoing clonal expansion are found recurrently in specific host genes
```{r sup_fig_S03, fig.width=4, fig.height=4}
freq_clonal_exp <- within(
  list(), {
    pct <- 0.05
    permute_cnt <- 100
    min_pats <- 3
    set.seed(1)
    
    # Analysis of patient samples ----
    #gene_cnts_by_pat_rel_tp <- cond_uniq_sites %>% 
    #  as.data.frame(row.names = NULL) %>% 
    #  dplyr::filter(timepoint != "d0", patient %in% std_clin_patients) %>% 
    #  dplyr::group_by(patient, posid, gene_id_wo_annot) %>% 
    #  dplyr::summarise(max_est = max(estAbund), max_rel = max(relAbund)) %>% 
    #  dplyr::group_by(patient) %>% 
    #  dplyr::filter(max_rel >= quantile(max_rel, probs = 1 - pct)) %>%
    #  dplyr::summarise(gene_cnt = n_distinct(gene_id_wo_annot))
    
    gene_cnts_by_pat_est_tp <- cond_uniq_sites %>% 
      as.data.frame(row.names = NULL) %>% 
      dplyr::filter(timepoint != "d0", patient %in% std_clin_patients) %>% 
      dplyr::group_by(patient, posid, gene_id_wo_annot) %>% 
      dplyr::summarise(max_est = max(estAbund), max_rel = max(relAbund)) %>% 
      dplyr::group_by(patient) %>% 
      dplyr::filter(max_est >= quantile(max_est, probs = 1 - pct)) %>%
      dplyr::summarise(gene_cnt = n_distinct(gene_id_wo_annot))

    # top_genes_rel_tp <- cond_uniq_sites %>% 
    #   as.data.frame(row.names = NULL) %>% 
    #   dplyr::filter(timepoint != "d0", patient %in% std_clin_patients) %>% 
    #   dplyr::group_by(patient, posid, gene_id_wo_annot) %>% 
    #   dplyr::summarise(max_est = max(estAbund), max_rel = max(relAbund)) %>% 
    #   dplyr::group_by(patient) %>% 
    #   dplyr::filter(max_rel >= quantile(max_rel, probs = 1 - pct)) %>% 
    #   dplyr::group_by(gene_id_wo_annot) %>% 
    #   dplyr::summarise(
    #     n_pats = n_distinct(patient), n_clones = n_distinct(patient, posid)
    #   ) %>% 
    #   dplyr::ungroup() %>% 
    #   dplyr::arrange(desc(n_pats)) %>% 
    #   dplyr::filter(n_pats >= min_pats)

    top_genes_est_tp <- cond_uniq_sites %>% 
      as.data.frame(row.names = NULL) %>% 
      dplyr::filter(timepoint != "d0", patient %in% std_clin_patients) %>% 
      dplyr::group_by(patient, posid, gene_id_wo_annot) %>% 
      dplyr::summarise(max_est = max(estAbund), max_rel = max(relAbund)) %>% 
      dplyr::group_by(patient) %>% 
      dplyr::filter(max_est >= quantile(max_est, probs = 1 - pct)) %>% 
      dplyr::group_by(gene_id_wo_annot) %>% 
      dplyr::summarise(
        n_pats = n_distinct(patient), n_clones = n_distinct(patient, posid)
      ) %>% 
      dplyr::ungroup() %>% 
      dplyr::arrange(desc(n_pats)) %>% 
      dplyr::filter(n_pats >= min_pats)

    ## Generate random sampling data ----
    ## and identify the number of genes overlapping
    # permute_data_rel_tp <- dplyr::bind_rows(
    #     lapply(seq_len(permute_cnt), function(i){
    # 
    #       cond_uniq_sites %>%
    #         as.data.frame(row.names = NULL) %>%
    #         dplyr::filter(timepoint != "d0", patient %in% std_clin_patients) %>%
    #         dplyr::group_by(patient, gene_id_wo_annot) %>%
    #         dplyr::summarise(max_est = max(estAbund), max_rel = max(relAbund)) %>%
    #         dplyr::group_by(patient) %>%
    #         dplyr::mutate(
    #           ord = sample.int(n = n(), size = n(), replace = FALSE)
    #         ) %>%
    #         dplyr::filter(
    #           ord <= gene_cnts_by_pat_rel_tp$gene_cnt[
    #             match(unique(patient), gene_cnts_by_pat_rel_tp$patient)
    #           ]
    #         ) %>%
    #         dplyr::group_by(gene_id_wo_annot) %>%
    #         dplyr::summarise(n_pats = n_distinct(patient)) %>%
    #         dplyr::ungroup() %>%
    #         dplyr::arrange(desc(n_pats)) %>%
    #         dplyr::filter(n_pats >= min_pats) %>%
    #         dplyr::group_by(n_pats) %>%
    #         dplyr::summarise(cnt = n())
    # 
    #     }),
    #     .id = "permute"
    #   ) %>%
    #   dplyr::mutate(
    #     permute = factor(permute),
    #     n_pats = factor(n_pats)
    #   ) %>%
    #   tidyr::complete(permute, n_pats, fill = list(cnt = 0)) %>%
    #   dplyr::mutate(
    #     n_pats = as.numeric(as.character(n_pats))
    #   )
    
    permute_data_est_tp <- dplyr::bind_rows(
        lapply(seq_len(permute_cnt), function(i){
        
          cond_uniq_sites %>%
            as.data.frame(row.names = NULL) %>%
            dplyr::filter(timepoint != "d0", patient %in% std_clin_patients) %>%
            dplyr::group_by(patient, gene_id_wo_annot) %>%
            dplyr::summarise(max_est = max(estAbund), max_rel = max(relAbund)) %>% 
            dplyr::group_by(patient) %>%
            dplyr::mutate(
              ord = sample.int(n = n(), size = n(), replace = FALSE)
            ) %>%
            dplyr::filter(
              ord <= gene_cnts_by_pat_est_tp$gene_cnt[
                match(unique(patient), gene_cnts_by_pat_est_tp$patient)
              ]
            ) %>%
            dplyr::group_by(gene_id_wo_annot) %>% 
            dplyr::summarise(n_pats = n_distinct(patient)) %>%
            dplyr::ungroup() %>% 
            dplyr::arrange(desc(n_pats)) %>% 
            dplyr::filter(n_pats >= min_pats) %>%
            dplyr::group_by(n_pats) %>%
            dplyr::summarise(cnt = n())
      
        }),
        .id = "permute"
      ) %>%
      dplyr::mutate(
        permute = factor(permute),
        n_pats = factor(n_pats)
      ) %>%
      tidyr::complete(permute, n_pats, fill = list(cnt = 0)) %>%
      dplyr::mutate(
        n_pats = as.numeric(as.character(n_pats))
      )
    
    ## From permutation data, generate probability densities of overlaps ----
    # permute_rel_tp_densities <- split(
    #     permute_data_rel_tp$cnt, permute_data_rel_tp$n_pats
    #   ) %>%
    #   lapply(density)
    
    permute_est_tp_densities <- split(
        permute_data_est_tp$cnt, permute_data_est_tp$n_pats
      ) %>%
      lapply(density)
    
    ## Generate summary data.frames ----
    # summary_top_gene_cnts_rel_tp <- top_genes_rel_tp %>%
    #   dplyr::group_by(n_pats) %>%
    #   dplyr::summarise(cnt = n()) %>%
    #   dplyr::mutate(
    #     p.value = mapply(
    #       function(cnt, pats){
    #         if( pats %in% names(permute_rel_tp_densities) ){
    #           
    #           idx <- match(
    #             cnt, round(permute_rel_tp_densities[[as.character(pats)]]$x)
    #           )
    #           
    #           if( is.na(idx) ){
    #             idx <- length(permute_rel_tp_densities[[as.character(pats)]]$x)
    #           }
    #           
    #           return(with(
    #             permute_rel_tp_densities[[as.character(pats)]], 
    #             1 - sum(y[seq_len(idx)] * rep(diff(x)[1], idx))
    #           ))
    #           
    #         }else{
    #           return(NA)
    #         }
    #       },
    #       cnt = cnt,
    #       pats = n_pats
    #     )
    #   )
    
    summary_top_gene_cnts_est_tp <- top_genes_est_tp %>%
      dplyr::group_by(n_pats) %>%
      dplyr::summarise(cnt = n()) %>%
      dplyr::mutate(
        p.value = mapply(
          function(cnt, pats){
            if( pats %in% names(permute_est_tp_densities) ){
              
              idx <- match(
                cnt, round(permute_est_tp_densities[[as.character(pats)]]$x)
              )
              
              if( is.na(idx) ){
                idx <- length(permute_est_tp_densities[[as.character(pats)]]$x)
              }
              
              return(with(
                permute_est_tp_densities[[as.character(pats)]], 
                1 - sum(y[seq_len(idx)] * rep(diff(x)[1], idx))
              ))
              
            }else{
              return(NA)
            }
          },
          cnt = cnt,
          pats = n_pats
        )
      )
    
    # permute_gene_summary_rel_tp <- permute_data_rel_tp %>%
    #   dplyr::group_by(n_pats) %>%
    #   dplyr::summarise(
    #     mean = mean(cnt), 
    #     sd = sd(cnt),
    #     norm.test = shapiro.test(cnt)$p.value
    #   )

    permute_gene_summary_est_tp <- permute_data_est_tp %>%
      dplyr::group_by(n_pats) %>%
      dplyr::summarise(
        mean = mean(cnt), 
        sd = sd(cnt),
        norm.test = shapiro.test(cnt)$p.value
      )
    
    # permute_count_summary_rel_tp <- dplyr::left_join(
    #     summary_top_gene_cnts_rel_tp, permute_gene_summary_rel_tp, by = "n_pats"
    #   ) %>%
    #   dplyr::mutate(
    #     p.value = ifelse(is.na(p.value), 0, p.value),
    #     cnt_log = log10(cnt),
    #     mean_log = log10(mean),
    #     max_mean_log = log10(mean + sd),
    #     min_mean_log = ifelse(mean - sd < 0, -2, log10(mean - sd))
    #   )
    
    permute_count_summary_est_tp <- dplyr::left_join(
        summary_top_gene_cnts_est_tp, permute_gene_summary_est_tp, by = "n_pats"
      ) %>%
      dplyr::mutate(
        p.value = ifelse(is.na(p.value), 0, p.value),
        cnt_log = log10(cnt),
        mean_log = log10(mean),
        max_mean_log = log10(mean + sd),
        min_mean_log = ifelse(mean - sd < 0, -2, log10(mean - sd))
      )
    
    ## Timepoint plots ----
    # rel_tp_summary_plot <- ggplot() +
    #   geom_linerange(
    #     data = permute_count_summary_rel_tp,
    #     aes(x = n_pats, ymin = min_mean_log, ymax = max_mean_log)
    #   ) +
    #   geom_point(
    #     data = {
    #       permute_count_summary_rel_tp %>%
    #         dplyr::select(n_pats, cnt_log, mean_log) %>%
    #         tidyr::gather(key = "data", value = "cnt_log", -n_pats) %>%
    #         dplyr::mutate(
    #           data = ifelse(data == "cnt_log", "Patient", "Permutation"),
    #           data = factor(data, levels = c("Permutation", "Patient"))
    #         )
    #     },
    #     aes(x = n_pats, y = cnt_log, fill = data),
    #     color = "black", shape = 21, size = 3
    #   ) + 
    #   scale_x_continuous(
    #     breaks = seq(min_pats, max(summary_top_gene_cnts_rel_tp$n_pats), 1)
    #   ) +
    #   geom_text(
    #     data = permute_count_summary_rel_tp,
    #     aes(x = n_pats, y = cnt_log, label = ifelse(p.value <= 0.05, "*", " ")), 
    #     size = 8, color = "black", nudge_y = 0.05, nudge_x = 0.05
    #   ) +
    #   scale_fill_brewer(palette = "Set1") +
    #   scale_y_continuous(
    #     breaks = c(-1, 0, 1, 2), 
    #     labels = c(bquote(10^-1), bquote(10^0), bquote(10^1), bquote(10^2))
    #   ) +
    #   coord_cartesian(ylim = c(-1, 2.5)) +
    #   labs(
    #     title = "Patient Samples - Rel. Abund.",
    #     x = "Number of patients transcription\nunits were shared across", 
    #     y = "Number of transcription units shared",
    #     fill = "Data Type"
    #   ) +
    #   custom_theme +
    #   theme(
    #     legend.position = c(0.8, 0.75),
    #     axis.line = element_line(color = "black")
    #   )
    
    est_tp_summary_plot <- ggplot() +
      geom_linerange(
        data = permute_count_summary_est_tp,
        aes(x = n_pats, ymin = min_mean_log, ymax = max_mean_log)
      ) +
      geom_point(
        data = {
          permute_count_summary_est_tp %>%
            dplyr::select(n_pats, cnt_log, mean_log) %>%
            tidyr::gather(key = "data", value = "cnt_log", -n_pats) %>%
            dplyr::mutate(
              data = ifelse(data == "cnt_log", "Patient", "Permutation"),
              data = factor(data, levels = c("Permutation", "Patient"))
            )
        },
        aes(x = n_pats, y = cnt_log, fill = data),
        color = "black", shape = 21, size = 3
      ) + 
      scale_x_continuous(
        breaks = seq(min_pats, max(summary_top_gene_cnts_est_tp$n_pats), 1)
      ) +
      geom_text(
        data = permute_count_summary_est_tp,
        aes(x = n_pats, y = cnt_log, label = ifelse(p.value <= 0.05, "*", " ")), 
        size = 8, color = "black", nudge_y = 0.05, nudge_x = 0.05
      ) +
      scale_fill_brewer(palette = "Set1") +
      scale_y_continuous(
        breaks = c(-1, 0, 1, 2), 
        labels = c(bquote(10^-1), bquote(10^0), bquote(10^1), bquote(10^2))
      ) +
      coord_cartesian(ylim = c(-1, 2.5)) +
      labs(
        title = "Patient Samples - Est. Abund.",
        x = "Number of patients transcription\nunits were shared across", 
        y = "Number of transcription units shared",
        fill = "Data Type"
      ) +
      custom_theme +
      theme(
        legend.position = c(0.8, 0.75),
        axis.line = element_line(color = "black")
      )
    
    # Analysis of infusion products ----
    # gene_cnts_by_pat_rel_tdn <- cond_uniq_sites %>% 
    #   as.data.frame(row.names = NULL) %>% 
    #   dplyr::filter(timepoint == "d0", patient %in% std_clin_patients) %>% 
    #   dplyr::group_by(patient, posid, gene_id_wo_annot) %>% 
    #   dplyr::summarise(max_est = max(estAbund), max_rel = max(relAbund)) %>% 
    #   dplyr::group_by(patient) %>% 
    #   dplyr::filter(max_rel >= quantile(max_rel, probs = 1 - pct)) %>%
    #   dplyr::summarise(gene_cnt = n_distinct(gene_id_wo_annot))
    # 
    # gene_cnts_by_pat_est_tdn <- cond_uniq_sites %>% 
    #   as.data.frame(row.names = NULL) %>% 
    #   dplyr::filter(timepoint == "d0", patient %in% std_clin_patients) %>% 
    #   dplyr::group_by(patient, posid, gene_id_wo_annot) %>% 
    #   dplyr::summarise(max_est = max(estAbund), max_rel = max(relAbund)) %>% 
    #   dplyr::group_by(patient) %>% 
    #   dplyr::filter(max_est >= quantile(max_est, probs = 1 - pct)) %>%
    #   dplyr::summarise(gene_cnt = n_distinct(gene_id_wo_annot))
    # 
    # top_genes_rel_tdn <- cond_uniq_sites %>% 
    #   as.data.frame(row.names = NULL) %>% 
    #   dplyr::filter(timepoint == "d0", patient %in% std_clin_patients) %>% 
    #   dplyr::group_by(patient, posid, gene_id_wo_annot) %>% 
    #   dplyr::summarise(max_est = max(estAbund), max_rel = max(relAbund)) %>% 
    #   dplyr::group_by(patient) %>% 
    #   dplyr::filter(max_rel >= quantile(max_rel, probs = 1 - pct)) %>% 
    #   dplyr::group_by(gene_id_wo_annot) %>% 
    #   dplyr::summarise(
    #     n_pats = n_distinct(patient), n_clones = n_distinct(patient, posid)
    #   ) %>% 
    #   dplyr::ungroup() %>% 
    #   dplyr::arrange(desc(n_pats)) %>% 
    #   dplyr::filter(n_pats >= min_pats)
    # 
    # top_genes_est_tdn <- cond_uniq_sites %>% 
    #   as.data.frame(row.names = NULL) %>% 
    #   dplyr::filter(timepoint == "d0", patient %in% std_clin_patients) %>% 
    #   dplyr::group_by(patient, posid, gene_id_wo_annot) %>% 
    #   dplyr::summarise(max_est = max(estAbund), max_rel = max(relAbund)) %>% 
    #   dplyr::group_by(patient) %>% 
    #   dplyr::filter(max_est >= quantile(max_est, probs = 1 - pct)) %>% 
    #   dplyr::group_by(gene_id_wo_annot) %>% 
    #   dplyr::summarise(
    #     n_pats = n_distinct(patient), n_clones = n_distinct(patient, posid)
    #   ) %>% 
    #   dplyr::ungroup() %>% 
    #   dplyr::arrange(desc(n_pats)) %>% 
    #   dplyr::filter(n_pats >= min_pats)
    # 
    # ## Generate random sampling data ----
    # ## and identify the number of genes overlapping
    # permute_data_rel_tdn <- dplyr::bind_rows(
    #     lapply(seq_len(permute_cnt), function(i){
    #     
    #       cond_uniq_sites %>%
    #         as.data.frame(row.names = NULL) %>%
    #         dplyr::filter(timepoint == "d0", patient %in% std_clin_patients) %>%
    #         dplyr::group_by(patient, gene_id_wo_annot) %>%
    #         dplyr::summarise(max_est = max(estAbund), max_rel = max(relAbund)) %>% 
    #         dplyr::group_by(patient) %>%
    #         dplyr::mutate(
    #           ord = sample.int(n = n(), size = n(), replace = FALSE)
    #         ) %>%
    #         dplyr::filter(
    #           ord <= gene_cnts_by_pat_rel_tdn$gene_cnt[
    #             match(unique(patient), gene_cnts_by_pat_rel_tdn$patient)
    #           ]
    #         ) %>%
    #         dplyr::group_by(gene_id_wo_annot) %>% 
    #         dplyr::summarise(n_pats = n_distinct(patient)) %>%
    #         dplyr::ungroup() %>% 
    #         dplyr::arrange(desc(n_pats)) %>% 
    #         dplyr::filter(n_pats >= min_pats) %>%
    #         dplyr::group_by(n_pats) %>%
    #         dplyr::summarise(cnt = n())
    #   
    #     }),
    #     .id = "permute"
    #   ) %>%
    #   dplyr::mutate(
    #     permute = factor(permute),
    #     n_pats = factor(n_pats)
    #   ) %>%
    #   tidyr::complete(permute, n_pats, fill = list(cnt = 0)) %>%
    #   dplyr::mutate(
    #     n_pats = as.numeric(as.character(n_pats))
    #   )
    # 
    # permute_data_est_tdn <- dplyr::bind_rows(
    #     lapply(seq_len(permute_cnt), function(i){
    #     
    #       cond_uniq_sites %>%
    #         as.data.frame(row.names = NULL) %>%
    #         dplyr::filter(timepoint == "d0", patient %in% std_clin_patients) %>%
    #         dplyr::group_by(patient, gene_id_wo_annot) %>%
    #         dplyr::summarise(max_est = max(estAbund), max_rel = max(relAbund)) %>% 
    #         dplyr::group_by(patient) %>%
    #         dplyr::mutate(
    #           ord = sample.int(n = n(), size = n(), replace = FALSE)
    #         ) %>%
    #         dplyr::filter(
    #           ord <= gene_cnts_by_pat_est_tdn$gene_cnt[
    #             match(unique(patient), gene_cnts_by_pat_est_tdn$patient)
    #           ]
    #         ) %>%
    #         dplyr::group_by(gene_id_wo_annot) %>% 
    #         dplyr::summarise(n_pats = n_distinct(patient)) %>%
    #         dplyr::ungroup() %>% 
    #         dplyr::arrange(desc(n_pats)) %>% 
    #         dplyr::filter(n_pats >= min_pats) %>%
    #         dplyr::group_by(n_pats) %>%
    #         dplyr::summarise(cnt = n())
    #   
    #     }),
    #     .id = "permute"
    #   ) %>%
    #   dplyr::mutate(
    #     permute = factor(permute),
    #     n_pats = factor(n_pats)
    #   ) %>%
    #   tidyr::complete(permute, n_pats, fill = list(cnt = 0)) %>%
    #   dplyr::mutate(
    #     n_pats = as.numeric(as.character(n_pats))
    #   )
    # 
    # ## From permutation data, generate probability densities of overlaps ----
    # permute_rel_tdn_densities <- split(
    #     permute_data_rel_tdn$cnt, permute_data_rel_tdn$n_pats
    #   ) %>%
    #   lapply(density)
    # 
    # permute_est_tdn_densities <- split(
    #     permute_data_est_tdn$cnt, permute_data_est_tdn$n_pats
    #   ) %>%
    #   lapply(density)
    # 
    # ## Generate summary data.frames ----
    # summary_top_gene_cnts_rel_tdn <- top_genes_rel_tdn %>%
    #   dplyr::group_by(n_pats) %>%
    #   dplyr::summarise(cnt = n()) %>%
    #   dplyr::mutate(
    #     p.value = mapply(
    #       function(cnt, pats){
    #         if( pats %in% names(permute_rel_tdn_densities) ){
    #           
    #           idx <- match(
    #             cnt, round(permute_rel_tdn_densities[[as.character(pats)]]$x)
    #           )
    #           
    #           if( is.na(idx) ){
    #             idx <- length(permute_rel_tdn_densities[[as.character(pats)]]$x)
    #           }
    #           
    #           return(with(
    #             permute_rel_tdn_densities[[as.character(pats)]], 
    #             1 - sum(y[seq_len(idx)] * rep(diff(x)[1], idx))
    #           ))
    #           
    #         }else{
    #           return(NA)
    #         }
    #       },
    #       cnt = cnt,
    #       pats = n_pats
    #     )
    #   )
    # 
    # summary_top_gene_cnts_est_tdn <- top_genes_est_tdn %>%
    #   dplyr::group_by(n_pats) %>%
    #   dplyr::summarise(cnt = n()) %>%
    #   dplyr::mutate(
    #     p.value = mapply(
    #       function(cnt, pats){
    #         if( pats %in% names(permute_est_tdn_densities) ){
    #           
    #           idx <- match(
    #             cnt, round(permute_est_tdn_densities[[as.character(pats)]]$x)
    #           )
    #           
    #           if( is.na(idx) ){
    #             idx <- length(permute_est_tdn_densities[[as.character(pats)]]$x)
    #           }
    #           
    #           return(with(
    #             permute_est_tdn_densities[[as.character(pats)]], 
    #             1 - sum(y[seq_len(idx)] * rep(diff(x)[1], idx))
    #           ))
    #           
    #         }else{
    #           return(NA)
    #         }
    #       },
    #       cnt = cnt,
    #       pats = n_pats
    #     )
    #   )
    # 
    # permute_gene_summary_rel_tdn <- permute_data_rel_tdn %>%
    #   dplyr::group_by(n_pats) %>%
    #   dplyr::summarise(
    #     mean = mean(cnt), 
    #     sd = sd(cnt),
    #     norm.test = shapiro.test(cnt)$p.value
    #   )
    # 
    # permute_gene_summary_est_tdn <- permute_data_est_tdn %>%
    #   dplyr::group_by(n_pats) %>%
    #   dplyr::summarise(
    #     mean = mean(cnt), 
    #     sd = sd(cnt),
    #     norm.test = shapiro.test(cnt)$p.value
    #   )
    # 
    # permute_count_summary_rel_tdn <- dplyr::left_join(
    #     summary_top_gene_cnts_rel_tdn, 
    #     permute_gene_summary_rel_tdn, 
    #     by = "n_pats"
    #   ) %>%
    #   dplyr::mutate(
    #     p.value = ifelse(is.na(p.value), 0, p.value),
    #     cnt_log = log10(cnt),
    #     mean_log = log10(mean),
    #     max_mean_log = log10(mean + sd),
    #     min_mean_log = ifelse(mean - sd < 0, -2, log10(mean - sd))
    #   )
    # 
    # permute_count_summary_est_tdn <- dplyr::left_join(
    #     summary_top_gene_cnts_est_tdn, 
    #     permute_gene_summary_est_tdn, 
    #     by = "n_pats"
    #   ) %>%
    #   dplyr::mutate(
    #     p.value = ifelse(is.na(p.value), 0, p.value),
    #     cnt_log = log10(cnt),
    #     mean_log = log10(mean),
    #     max_mean_log = log10(mean + sd),
    #     min_mean_log = ifelse(mean - sd < 0, -2, log10(mean - sd))
    #   )
    # 
    # ## Infusion product plots ----
    # rel_tdn_summary_plot <- ggplot() +
    #   geom_linerange(
    #     data = permute_count_summary_rel_tdn,
    #     aes(x = n_pats, ymin = min_mean_log, ymax = max_mean_log)
    #   ) +
    #   geom_point(
    #     data = {
    #       permute_count_summary_rel_tdn %>%
    #         dplyr::select(n_pats, cnt_log, mean_log) %>%
    #         tidyr::gather(key = "data", value = "cnt_log", -n_pats) %>%
    #         dplyr::mutate(
    #           data = ifelse(data == "cnt_log", "Patient", "Permutation"),
    #           data = factor(data, levels = c("Permutation", "Patient"))
    #         )
    #     },
    #     aes(x = n_pats, y = cnt_log, fill = data),
    #     color = "black", shape = 21, size = 3
    #   ) + 
    #   scale_x_continuous(breaks = scales::pretty_breaks()) +
    #   geom_text(
    #     data = permute_count_summary_rel_tdn,
    #     aes(x = n_pats, y = cnt_log, label = ifelse(p.value <= 0.05, "*", " ")), 
    #     size = 8, color = "black", nudge_y = 0.05, nudge_x = 0.05
    #   ) +
    #   scale_fill_brewer(palette = "Set1") +
    #   scale_y_continuous(
    #     breaks = c(-1, 0, 1, 2, 3), 
    #     labels = c(
    #       bquote(10^-1), bquote(10^0), bquote(10^1), bquote(10^2), bquote(10^3)
    #     )
    #   ) +
    #   coord_cartesian(ylim = c(-1, 3)) +
    #   labs(
    #     title = "Infusion Products - Rel. Abund.",
    #     x = "Number of patients transcription\nunits were shared across", 
    #     y = "Number of transcription units shared",
    #     fill = "Data Type"
    #   ) +
    #   custom_theme +
    #   theme(
    #     legend.position = c(0.8, 0.75),
    #     axis.line = element_line(color = "black")
    #   )
    # 
    # est_tdn_summary_plot <- ggplot() +
    #   geom_linerange(
    #     data = permute_count_summary_est_tdn,
    #     aes(x = n_pats, ymin = min_mean_log, ymax = max_mean_log)
    #   ) +
    #   geom_point(
    #     data = {
    #       permute_count_summary_est_tdn %>%
    #         dplyr::select(n_pats, cnt_log, mean_log) %>%
    #         tidyr::gather(key = "data", value = "cnt_log", -n_pats) %>%
    #         dplyr::mutate(
    #           data = ifelse(data == "cnt_log", "Patient", "Permutation"),
    #           data = factor(data, levels = c("Permutation", "Patient"))
    #         )
    #     },
    #     aes(x = n_pats, y = cnt_log, fill = data),
    #     color = "black", shape = 21, size = 3
    #   ) + 
    #   scale_x_continuous(breaks = scales::pretty_breaks()) +
    #   geom_text(
    #     data = permute_count_summary_est_tdn,
    #     aes(x = n_pats, y = cnt_log, label = ifelse(p.value <= 0.05, "*", " ")), 
    #     size = 8, color = "black", nudge_y = 0.05, nudge_x = 0.05
    #   ) +
    #   scale_fill_brewer(palette = "Set1") +
    #   scale_y_continuous(
    #     breaks = c(-1, 0, 1, 2, 3), 
    #     labels = c(
    #       bquote(10^-1), bquote(10^0), bquote(10^1), bquote(10^2), bquote(10^3)
    #     )
    #   ) +
    #   coord_cartesian(ylim = c(-1, 3)) +
    #   labs(
    #     title = "Infusion Products - Est. Abund.",
    #     x = "Number of patients transcription\nunits were shared across", 
    #     y = "Number of transcription units shared",
    #     fill = "Data Type"
    #   ) +
    #   custom_theme +
    #   theme(
    #     legend.position = c(0.8, 0.75),
    #     axis.line = element_line(color = "black")
    #   )
    
  }
)

#high_abund_freq_plots <- list(
#  freq_clonal_exp$rel_tp_summary_plot,
#  freq_clonal_exp$est_tp_summary_plot,
#  freq_clonal_exp$rel_tdn_summary_plot,
#  freq_clonal_exp$est_tdn_summary_plot
#)

#grid.arrange(grobs = high_abund_freq_plots, nrow = 2)

freq_clonal_exp$est_tp_summary_plot +
  labs(title = NULL)
```
Figure S3. Integration sites in cells undergoing clonal expansion are found recurrently in specific host genes across multiple patients. We sought to test the possibility that the same clones expanded in abundance in multiple CART19 patients.  To assess this, we first selected the top 5% most abundant clones from each patient (based on SonicAbundance). We then plotted how often the genes marked by integration were found in the top 5% most abundant clones in other patients.  In the figure, the number of patients sharing an expanded clone is shown on the x-axis, and the y-axis shows the number of clones shared overall for the given number of patients sharing clones. For example, a total of 18 genes (y-axis) were shared across 7 patients (x-axis). To analyze the background of sharing expected by chance (taking account of differential integration frequency in different transcription units), we sampled a random 5% of genes from each patient, and repeated the overlap calculation. This was repeated 1000 times, and the resulting permutation background plotted (red dots). Error bars indicate Standard Deviation.  Thus the observed sharing is far greater than that expected by chance as reported by the permutation background. Specific genes detected are as follows: Observed across 7 patients: `r freq_clonal_exp$top_genes_est_tp %>% dplyr::filter(n_pats == 7) %$% paste(gene_id_wo_annot, collapse = ", ")`. Observed across 8 patients: `r freq_clonal_exp$top_genes_est_tp %>% dplyr::filter(n_pats == 8) %$% paste(gene_id_wo_annot, collapse = ", ")`. Observed across 9 patients: `r freq_clonal_exp$top_genes_est_tp %>% dplyr::filter(n_pats == 9) %$% paste(gene_id_wo_annot, collapse = ", ")`. Clones within genes `r freq_clonal_exp$top_genes_est_tp %>% dplyr::filter(n_pats > 9) %>% dplyr::arrange(n_pats) %$% paste(gene_id_wo_annot, collapse = " and ")` were observed across 11 and 12 patients, respectively.

\newpage
## Supplemental Figure 4. GO and KEGG enriched groups by gene selection criteria
```{r sup_fig_S04, fig.width=9, fig.height=6}
go_kegg_heatmaps <- within(
  list(), {

    # Filter down terms (GO and KEGG) that will be relavent to the analysis
    num_terms <- 20
    select_GOBP_list <- all_GOBP_list[
      lengths(all_GOBP_list) >= 10 & lengths(all_GOBP_list) <= 1000]
    select_go_terms <- data.frame(
        id = names(select_GOBP_list), 
        size = lengths(select_GOBP_list)) %>%
      dplyr::group_by(id) %>%
      dplyr::mutate(term = Term(GOTERM[[id]])) %>%
      dplyr::ungroup() %>%
      dplyr::filter(
        !grepl("placenta", term),
        !grepl("^negative", term),
        !grepl("^positive", term),
        !grepl("embryo", term),
        !grepl("estrous", term),
        !grepl("eating", term),
        !grepl("reproductive", term),
        !grepl("radiation", term),
        !grepl("development", term),
        !grepl("to heat", term),
        !grepl("response", term), 
        !grepl("organization", term),
        !grepl("assembly", term),
        !grepl("migration", term))
    
    select_GOBP_list <- select_GOBP_list[select_go_terms$id]
    
    
    rel_kegg_terms <- k_path %>%
      tolower() %>%
      grep("virus", x = ., invert = TRUE, value = TRUE) %>%
      grep("viral", x = ., invert = TRUE, value = TRUE) %>%
      grep("addiction", x = ., invert = TRUE, value = TRUE) %>%
      grep("metabol", x = ., invert = TRUE, value = TRUE) %>%
      grep("myopathy", x = ., invert = TRUE, value = TRUE) %>%
      grep("multiple species", x = ., invert = TRUE, value = TRUE)
   
    rel_kegg_terms <- rel_kegg_terms[
      grepl("signaling", rel_kegg_terms) | 
        grepl("differentiation", rel_kegg_terms) |
        grepl("proteolysis", rel_kegg_terms) |
        grepl("ptosis", rel_kegg_terms) |
        grepl("micrornas", rel_kegg_terms) |
        grepl("some", rel_kegg_terms) |
        grepl("cycle", rel_kegg_terms)]
    
    rel_kegg_terms <- names(rel_kegg_terms)

    # Import GOI report data and environment
    goi_analysis <- read.csv(
        file.path(
          outputDir, 
          grep("_cart19_goi_data.csv", list.files(outputDir), value = TRUE)
        )
      ) %>%
      dplyr::mutate(Gene_Name = gsub("'", "", Gene_Name)) 

    # GOI potential genes and analysis ----   
    potential_genes <- apply(
      as.matrix(goi_analysis[
        ,c("Depletion", "Enrichment", "Abundance", "Longitudinal")]), 
      2, function(x){
             goi_analysis$Gene_Name[x]
           })
    
    composite_genes <- unique(unlist(
      potential_genes[c("Enrichment", "Abundance", "Longitudinal")]
    ))

    criteria_order <- c(
      "Depletion", "Enrichment", "Abundance", "Longitudinal"
    )
    
    composite_go <- fisher_hyper_GO_test(
      gene_list = composite_genes, GO_list = select_GOBP_list, odds = FALSE, 
      p_adjust = "BH", lower_tail = FALSE, filter = TRUE, cores = numCores)
    
    select_GOBP_list <- select_GOBP_list[composite_go$GO_ID]
    
    composite_kegg <- fisher_hyper_KEGG_test(
      gene_list = composite_genes, KEGG_list = k_pathList[rel_kegg_terms], 
      odds = FALSE, p_adjust = "BH", lower_tail = FALSE, filter = FALSE, 
      cores = numCores)

    go_term <- lapply(potential_genes, function(x){
      fisher_hyper_GO_test(
        x, select_GOBP_list, odds = FALSE, 
        p_adjust = 'BH', lower_tail = FALSE, cutoff = 1) 
      })
    
    kegg_term <- lapply(potential_genes, function(x){
      fisher_hyper_KEGG_test(
        x, k_pathList[rel_kegg_terms], odds = FALSE, 
        p_adjust = 'BH', lower_tail = FALSE, cutoff = 1)
    })

    go_list_df <- bind_rows(go_term, .id = "Criteria") %>%
      dplyr::select(Criteria, GO_ID, GO_Term, overlap_size, adj.p.value)
    
    kegg_list_df <- bind_rows(kegg_term, .id = "Criteria") %>%
      dplyr::select(Criteria, path_id, KEGG_Term, overlap_size, adj.p.value)

    go_matrix <- sapply(potential_genes, function(x){
     sapply(select_GOBP_list, function(y){ sum(x %in% y) / length(y) }) })
    
    go_matrix <- go_matrix[composite_go$GO_ID,]
        
    kegg_matrix <- sapply(potential_genes, function(x){
     sapply(k_pathList, function(y){ sum(x %in% y) / length(y) }) })
    
    kegg_matrix <- kegg_matrix[composite_kegg$path_id,]
    
    # top x terms
    top_go_terms <- rownames(go_matrix)[seq_len(num_terms)]
    top_kegg_terms <- rownames(kegg_matrix)[seq_len(num_terms)]
    
    top_go_df <- data.frame(
        term = top_go_terms,
        size = lengths(select_GOBP_list[top_go_terms]),
        ovlp = sapply(select_GOBP_list[top_go_terms], function(x){
          sum(composite_genes %in% x) }), 
        adj.p.value = composite_go$adj.p.value[match(
          top_go_terms, composite_go$GO_ID)],
        clus = as.vector(cluster_by_list_similarity(
          keys = top_go_terms, keyList = select_GOBP_list[top_go_terms]))) %>%
      dplyr::arrange(clus, desc(ovlp), adj.p.value)
    
    top_kegg_df <- data.frame(
        term = top_kegg_terms,
        size = lengths(k_pathList[top_kegg_terms]),
        ovlp = sapply(k_pathList[top_kegg_terms], function(x){
          sum(composite_genes %in% x) }), 
        adj.p.value = composite_kegg$adj.p.value[match(
          top_kegg_terms, composite_kegg$path_id)],
        clus = as.vector(cluster_by_list_similarity(
          keys = top_kegg_terms, keyList = k_pathList[top_kegg_terms]))) %>%
      dplyr::arrange(clus, desc(ovlp), adj.p.value)
    
    go_heatmap_data <- as.data.frame(go_matrix[top_go_df$term,]) %>%
      dplyr::mutate(
        GO_ID = row.names(.),
        GO_Term = go_list_df$GO_Term[match(GO_ID, go_list_df$GO_ID)],
        f_GO_term = stringr::str_extract(GO_Term, "[\\w\\s-,]{40}"),
        f_GO_term = ifelse(is.na(f_GO_term), GO_Term, paste0(f_GO_term, "...")),
        f_GO_term = factor(f_GO_term, levels = rev(unique(f_GO_term)))) %>%
      tidyr::gather(
        key = "Criteria", value = "Proportion", 
        -GO_ID, -GO_Term, -f_GO_term) %>%
      left_join(
        dplyr::select(go_list_df, -GO_Term), 
        by = c("GO_ID", "Criteria")) %>%
      dplyr::mutate(
        Proportion = ifelse(Proportion == 0, NA, Proportion),
        Criteria = factor(Criteria, levels = criteria_order),
        Sig = ifelse(
          !is.na(adj.p.value), ifelse(adj.p.value <= 0.05, "*", " "), " ")) %>%
      dplyr::mutate(section = ifelse(Criteria == "Depletion", 1, 2))
    
    kegg_heatmap_data <- as.data.frame(kegg_matrix[top_kegg_df$term,]) %>%
      dplyr::mutate(
        path_id = row.names(.),
        KEGG_Term = kegg_list_df$KEGG_Term[
          match(path_id, kegg_list_df$path_id)],
        KEGG_Term = stringr::str_remove(
          KEGG_Term, fixed(" - Homo sapiens (human)")),
        f_KEGG_term = stringr::str_extract(KEGG_Term, "[\\w\\s-,]{40}"),
        f_KEGG_term = ifelse(
          is.na(f_KEGG_term), KEGG_Term, paste0(f_KEGG_term, "...")),
        f_KEGG_term = factor(
          f_KEGG_term, levels = rev(unique(f_KEGG_term)))) %>%
      tidyr::gather(
        key = "Criteria", value = "Proportion", 
        -path_id, -KEGG_Term, -f_KEGG_term) %>%
      left_join(
        dplyr::select(kegg_list_df, -KEGG_Term), 
        by = c("path_id", "Criteria")) %>%
      dplyr::mutate(
        Proportion = ifelse(Proportion == 0, NA, Proportion),
        Criteria = factor(Criteria, levels = criteria_order),
        Sig = ifelse(
          !is.na(adj.p.value), ifelse(adj.p.value <= 0.05, "*", " "), " ")) %>%
      dplyr::mutate(section = ifelse(Criteria == "Depletion", 1, 2))

    go_heatmap <- go_heatmap_data %>%
        ggplot(aes(x = Criteria, y = f_GO_term)) +
        geom_tile(aes(fill = Proportion)) +
        geom_text(aes(label = Sig)) +
        facet_grid(. ~ section, scales = "free", space = "free") +  
        scale_fill_distiller(
          type = "seq", palette = "Blues", direction = 1, na.value = "white",
          breaks = c(0, 0.05, 0.1)) +
        scale_y_discrete(position = "right") +
        scale_x_discrete(position = "top") + 
        labs(y = NULL, fill = "Term Proportion") +
        guides(fill = guide_colorbar(
          title.position = "top", label.position = "bottom")) +
        theme(
          panel.background = element_blank(),
          axis.text.x.top = element_text(angle = 90, vjust = 0.5, hjust = 0),
          legend.position = "bottom",
          axis.title = element_text(color = "black", face = "bold"),
          legend.title = element_text(color = "black", face = "bold"),
          axis.text = element_text(color = "black"),
          strip.placement = "outside",
          strip.background = element_blank(),
          strip.text = element_blank(),
          aspect.ratio = length(unique(go_heatmap_data$GO_ID)) /
            nrow(dplyr::distinct(go_heatmap_data, Criteria)))
    
      kegg_heatmap <- kegg_heatmap_data %>%
        ggplot(aes(x = Criteria, y = f_KEGG_term)) +
        geom_tile(aes(fill = Proportion)) +
        geom_text(aes(label = Sig)) +
        facet_grid(. ~ section, scales = "free", space = "free") +  
        scale_fill_distiller(
          type = "seq", palette = "Greens", direction = 1, na.value = "white",
          breaks = c(0, 0.05, 0.1)) +
        scale_y_discrete(position = "right") +
        scale_x_discrete(position = "top") + 
        labs(y = NULL, fill = "Term Proportion") +
        guides(fill = guide_colorbar(
          title.position = "top", label.position = "bottom")) +
        theme(
          panel.background = element_blank(),
          axis.text.x.top = element_text(angle = 90, vjust = 0.5, hjust = 0),
          legend.position = "bottom",
          axis.title = element_text(color = "black", face = "bold"),
          legend.title = element_text(color = "black", face = "bold"),
          axis.text = element_text(color = "black"),
          strip.placement = "outside",
          strip.background = element_blank(),
          strip.text = element_blank(),
          aspect.ratio = length(unique(kegg_heatmap_data$path_id)) /
            nrow(dplyr::distinct(kegg_heatmap_data, Criteria)))
      
  }
)

grid.arrange(
  grobs = list(
    go_kegg_heatmaps$go_heatmap, 
    go_kegg_heatmaps$kegg_heatmap), 
  nrow = 1
)
```
Figure S4. Gene ontology analysis of genes called as influencing T cell proliferation. Heatmaps indicating the proportion of each gene ontology term (A) or KEGG pathway (B). The four criteria for calling genes were each analyzed separately (columns). Asterisks indicate significant enrichment for the term over random distributions (Fisher's exact test based on noncentral hypergeometic distributions).

\newpage
## Supplemental Figure 5. Comparing clonal diversity by TCR and VIS
```{r sup_fig_S05, fig.width=5, fig.height=3}
tcr_summary <- within(
  list(), {

    ## Load data TCR and IgH data into list environment for analysis.
    data_files <- list.files(outputDir)
    file_specimen <- grep("specimen_data", data_files, value = TRUE)
    file_specimen_data <- grep("specimen_summary", data_files, value = TRUE)
    file_tcr_igh_data <- grep(
      "tcr_igh_sample_data", data_files, value = TRUE
    )

    specimen_data <- read.csv(file.path(outputDir, file_specimen_data)) %>%
      dplyr::select(
        patient, disease, response, clin_trial, simple_response, general_response,
        determinant_response, celltype, timepoint, specimen, 
        "is.richness" = numUniqSites, "is.shannon" = ShannonIndex, 
        "is.gini" = GiniIndex, "is.chao" = Chao1, "is.uc50" = UC50
      ) %>%
      dplyr::mutate(
        celltype = factor(celltype, levels = celltypeLevels),
        timepoint = factor(timepoint, levels = timepointLevels),
        is.richness = as.numeric(is.richness),
        is.shannon = as.numeric(is.shannon),
        is.gini = as.numeric(is.gini),
        is.chao = as.numeric(is.chao),
        is.uc50 = as.numeric(is.uc50)
      )
    
    full_tcr_data <- read.csv(file.path(outputDir, file_tcr_igh_data)) %>%
      dplyr::select(
        patient, celltype, timepoint, locus, sample_name, 
        "tcr.shannon" = shannon, "tcr.gini" = gini, "tcr.uc50" = uc50
      ) %>%
      dplyr::mutate(
        celltype = factor(celltype, levels = celltypeLevels),
        timepoint = factor(timepoint, levels = timepointLevels),
        tcr.shannon = as.numeric(tcr.shannon),
        tcr.gini = as.numeric(tcr.gini),
        tcr.uc50 = as.numeric(tcr.uc50)
      ) %>%
      dplyr::filter(!is.na(celltype) & !is.na(timepoint), locus == "TCRB") %>%
      dplyr::mutate(is.car.pos = ifelse(
        as.character(timepoint) == "d0", grepl("CAR+", celltype), TRUE
      )) %>%
      dplyr::filter(is.car.pos)

    ## Annotate which specimens have matching intsite data
    specimen_coerce <- dplyr::select(specimen_data, patient, timepoint) %>% 
      dplyr::mutate(timepoint = as.character(timepoint)) %>%
      dplyr::distinct()
    
    tcr_coerce <- dplyr::select(full_tcr_data, patient, timepoint) %>%
      dplyr::mutate(
        patient = as.character(patient),
        timepoint = as.character(timepoint)
      ) %>%
      dplyr::distinct()
    
    tcr_is_intersect <- dplyr::intersect(specimen_coerce, tcr_coerce)
    
    is_data <- specimen_data %>%
      dplyr::select(
        patient, celltype, timepoint, is.shannon, is.gini, is.uc50
      ) %>%
      dplyr::filter(
        patient %in% tcr_is_intersect$patient & 
          timepoint %in% tcr_is_intersect$timepoint
      ) %>%
      tidyr::gather(
        key = "metric", value = "value", -patient, -celltype, -timepoint
      )
    
    tcr_data <- full_tcr_data %>%
      dplyr::select(
        patient, celltype, timepoint, tcr.shannon, tcr.gini, tcr.uc50
      ) %>%
      dplyr::filter(
        patient %in% tcr_is_intersect$patient & 
          timepoint %in% tcr_is_intersect$timepoint
      ) %>%
      tidyr::gather(
        key = "metric", value = "value", -patient, -celltype, -timepoint
      )
    
    # Combine tcr and is data
    metadata <- dplyr::bind_rows(is_data, tcr_data) %>%
      dplyr::group_by(patient, celltype, timepoint, metric) %>%
      dplyr::summarise(value = mean(value)) %>%
      dplyr::ungroup() %>%
      tidyr::spread(key = "metric", value = "value") %>%
      dplyr::arrange(patient, timepoint, celltype) %>%
      dplyr::group_by(patient, timepoint) %>%
      dplyr::mutate(
        is.gini = max(is.gini, na.rm = TRUE),
        is.shannon = max(is.shannon, na.rm = TRUE),
        is.uc50 = max(is.uc50, na.rm = TRUE),
        rel.timepoint = ifelse(
          timepoint == "d0", "Infusion Product", "Post-Therapy"
        ),
        rel.timepoint = factor(
          rel.timepoint, levels = c("Infusion Product", "Post-Therapy")
        ),
        rel.celltype = stringr::str_extract(as.character(celltype), "[\\w]+"),
        rel.celltype = ifelse(rel.celltype == "BMMC", "BM", rel.celltype),
        rel.celltype = ifelse(rel.celltype == "PBMC", "PBL", rel.celltype),
        rel.celltype = ifelse(rel.celltype == "PB", "PBL", rel.celltype),
        rel.celltype = ifelse(rel.celltype == "Tcells", "Tcells*", rel.celltype),
        rel.celltype = factor(rel.celltype, levels = c("Tcells*", "PBL", "BM"))
      ) %>%
      dplyr::filter(
        !is.na(tcr.gini) | !is.na(tcr.shannon) | !is.na(tcr.uc50),
        is.gini >= 0 & is.shannon >= 0 & is.uc50 >= 0,
        !grepl("CAR-", celltype)
      ) %>%
      dplyr::group_by(rel.celltype, rel.timepoint) %>%
      dplyr::filter(n() > 1, rel.celltype == "Tcells*") %>%
      dplyr::ungroup() %>%
      dplyr::arrange(rel.timepoint, rel.celltype) %>%
      dplyr::left_join(
        dplyr::distinct(specimen_data, patient, disease, determinant_response),
        by = "patient"
      ) %>%
      dplyr::mutate(
        determinant_response = factor(
          determinant_response, levels = c("PR_NR", "CR_PRtd")
        ),
        disease = factor(disease, levels = c("CLL", "aALL", "pALL"))
      )

    shannon_correlations <- metadata %>%
      split(., paste0(.$rel.celltype, " - ", .$rel.timepoint)) %>%
      lapply(function(x){
        y <- summary(lm(is.shannon ~ tcr.shannon, data = x))
        z <- cor.test(~ is.shannon + tcr.shannon, data = x, method = "spearman")
        
        if( nrow(x) > 1 ){
          return(data.frame(
            obs = nrow(x), m = y$coefficients[2], b = y$coefficients[1],
            mse = y$coefficients[4], bse = y$coefficients[3],
            adj.r.squared = y$adj.r.squared,
            p.value = pf(
              y$fstatistic["value"], y$fstatistic["numdf"], 
              y$fstatistic["dendf"], lower.tail = FALSE
            ),
            p.value.sp = z$p.value, 
            rho.sp = z$estimate
          ))
        }else{
          return(data.frame(
            obs = nrow(x), m = NA, b = NA, mse = NA, bse = NA, 
            adj.r.squared = NA, p.value = NA, p.value.sp = NA, rho.sp = NA
          ))
        }
      }) %>%
      dplyr::bind_rows(.id = "grouping") %>%
      tidyr::separate(
        col = grouping, 
        into = c("rel.celltype", "rel.timepoint"), 
        sep = " - "
      ) %>%
      dplyr::mutate(
        rel.celltype = factor(rel.celltype, levels = c("Tcells*", "PBL", "BM")),
        rel.timepoint = factor(
          rel.timepoint, levels = c(c("Infusion Product", "Post-Therapy"))
        ),
        r.squared.x = 1,
        r.squared.y = c(2, 7.5),
        r.squared.fmt = ifelse(
          is.na(adj.r.squared), 
          "", 
          paste0("R^2 = ", format(round(adj.r.squared, digits = 3)))
        ),
        # r.squared.fmt = ifelse(
        #   p.value <= 0.05, paste0(r.squared.fmt, "*"), r.squared.fmt
        # ),
        p.value.fmt = paste0(
          "p-value = ", format(round(p.value.sp, digits = 3))
        ),
        annot = paste0(r.squared.fmt, "\n", p.value.fmt)
      ) %>%
      dplyr::filter(obs > 1)

    # gini_correlations <- metadata %>%
    #   split(., paste0(.$rel.celltype, " - ", .$rel.timepoint)) %>%
    #   lapply(function(x){
    #     y <- summary(lm(is.gini ~ tcr.gini, data = x))
    #     z <- cor.test(~ is.gini + tcr.gini, data = x, method = "spearman")
    # 
    #     if( nrow(x) > 1 ){
    #       return(data.frame(
    #         obs = nrow(x), m = y$coefficients[2], b = y$coefficients[1],
    #         mse = y$coefficients[4], bse = y$coefficients[3],
    #         adj.r.squared = y$adj.r.squared,
    #         p.value = pf(
    #           y$fstatistic["value"], y$fstatistic["numdf"], 
    #           y$fstatistic["dendf"], lower.tail = FALSE
    #         ),
    #         p.value.sp = z$p.value, 
    #         rho.sp = z$estimate
    #       ))
    #     }else{
    #       return(data.frame(
    #         obs = nrow(x), m = NA, b = NA, mse = NA, bse = NA, 
    #         adj.r.squared = NA, p.value = NA, p.value.sp = NA, rho.sp = NA
    #       ))
    #       
    #     }
    #   }) %>%
    #   dplyr::bind_rows(.id = "grouping") %>%
    #   tidyr::separate(
    #     col = grouping, 
    #     into = c("rel.celltype", "rel.timepoint"), 
    #     sep = " - "
    #   ) %>%
    #   dplyr::mutate(
    #     rel.celltype = factor(rel.celltype, levels = c("Tcells*", "PBL", "BM")),
    #     rel.timepoint = factor(
    #       rel.timepoint, levels = c(c("Infusion Product", "Post-Therapy"))
    #     ),
    #     r.squared.x = 0.4,
    #     r.squared.y = 0.75,
    #     r.squared.fmt = ifelse(
    #       is.na(adj.r.squared), 
    #       "", 
    #       paste0("R^2 = ", format(round(adj.r.squared, digits = 3)))
    #     ),
    #     r.squared.fmt = ifelse(
    #       p.value <= 0.05, paste0(r.squared.fmt, "*"), r.squared.fmt
    #     )
    #   ) %>%
    #   dplyr::filter(obs > 1)

    shannon_plot <- ggplot() +
      geom_abline(
        data = shannon_correlations,
        aes(slope = m, intercept = b), 
        color = "grey50", alpha = 0.5, show.legend = FALSE
      ) +
      geom_point(
        data = metadata,
        aes(
          x = tcr.shannon, y = is.shannon, 
          fill = factor(determinant_response), shape = disease
        ),
        color = "black", stroke = 0.25, size = 2,
        show.legend = FALSE
      ) + 
      geom_text(
        data = shannon_correlations,
        aes(x = r.squared.x, y = r.squared.y, label = annot),
        hjust = 0, size = 3, parse = FALSE
      ) +
      scale_fill_brewer(palette = "Set1") +
      scale_y_continuous(
        breaks = c(0, 2, 4, 6, 8), 
        labels = c("0.0", "2.0", "4.0", "6.0", "8.0")
      ) +
      scale_shape_manual(values = c(21, 24, 25)) +
      facet_grid(. ~ rel.timepoint) +
      labs(
        x = "TCR Shannon Diversity", 
        y = "VIS Shannon Diversity"
      ) +
      custom_theme + 
      theme(
        panel.background = element_rect(color = "black")
      )
    
    # gini_plot <- ggplot() +
    #   geom_abline(
    #     data = gini_correlations,
    #     aes(slope = m, intercept = b), 
    #     color = "grey50", alpha = 0.5, show.legend = FALSE
    #   ) +
    #   geom_point(
    #     data = metadata,
    #     aes(
    #       x = tcr.gini, y = is.gini, 
    #       fill = determinant_response, shape = disease
    #     ),
    #     color = "black", stroke = 0.25, size = 2,
    #     show.legend = FALSE
    #   ) + 
    #   geom_text(
    #     data = gini_correlations,
    #     aes(x = r.squared.x, y = r.squared.y, label = r.squared.fmt),
    #     hjust = 0, size = 3
    #   ) +
    #   scale_fill_brewer(palette = "Set1") +
    #   scale_y_continuous(
    #     breaks = c(0, 0.2, 0.4, 0.6, 0.8), 
    #     labels = c("0.0", "0.2", "0.4", "0.6", "0.8")
    #   ) +
    #   scale_shape_manual(values = c(21, 24, 25)) +
    #   facet_grid(. ~ rel.timepoint + rel.celltype) +
    #   labs(
    #     x = "TCR Gini Index", 
    #     y = "VIS Gini Index"
    #   ) +
    #   custom_theme + 
    #   theme(
    #     panel.background = element_rect(color = "black")
    #   )
    
    metadata_cor <- metadata %>%
      dplyr::group_by(rel.celltype, rel.timepoint) %>%
      dplyr::summarise(
        cnt = n(),
        shannon.cor = cor(is.shannon, tcr.shannon),
        gini.cor = cor(is.gini, tcr.gini)
      )

    shannon_cor_tbl <- metadata_cor %>%
      dplyr::filter(cnt > 1) %>%
      dplyr::mutate(
        shannon.fmt = paste0(
          format(round(shannon.cor, digits = 3)), " (", cnt, ")"
        )
      ) %>%
      dplyr::select(rel.celltype, rel.timepoint, shannon.fmt) %>%
      tidyr::spread(key = rel.celltype, value = shannon.fmt, fill = "NA")

    # gini_cor_tbl <- metadata_cor %>%
    #   dplyr::filter(cnt > 1) %>%
    #   dplyr::mutate(
    #     gini.fmt = paste0(
    #       format(round(gini.cor, digits = 3)), " (", cnt, ")"
    #     )
    #   ) %>%
    #   dplyr::select(rel.celltype, rel.timepoint, gini.fmt) %>%
    #   tidyr::spread(key = rel.celltype, value = gini.fmt, fill = "NA")
    
  }
)

tcr_summary$shannon_plot

#knitr::kable(
#    x = tcr_summary$shannon_cor_tbl, 
#    format = "latex", booktabs = TRUE
#  ) %>%
#  kableExtra::kable_styling(latex_options = "hold_position")

```
Figure S5. Comparing clonal diversity between TCR-beta sequencing results from CART19 sorted T-cells and vector integration sites from peripheral blood (measured by Shannon Index). P-values were determined from the Spearman correlation. Blue points indicate data from CR/PRtd patients, red points indicate data from PR/NR patients. Circles represent patients with CLL, triangles represent patients with ALL (upward pointing, Adult ALL; downward pointing, Pediatric ALL).  All TCR-beta sequencing data was collected from CAR+ sorted T-cells. T cell subsets analyzed included CD3+, CART19+, and in some cases CD4+-sorted or CD8+-sorted.

\newpage
## Supplemental Figure 6. Model optimization based on vector integration sites from infusion products or day 28 samples
```{r sup_fig_S06, fig.height=3.5, fig.width=7}
model_analysis <- within(
  model_analysis, {
    # TDN Model cross-validation
    lambda_plot_tdn <- plot_lasso(cv_tdn_pca, minOnly = TRUE) +
      labs(title = "Transduction Product Model") +
      theme(plot.title = element_text(size = 10, face = "bold"))
    
    lambda_plot_mod_tdn <- plot_lasso_mod(
        cv_tdn_pca, custom_breaks = c(21, 20, 19, 17, 15, 4), minOnly = TRUE) +
      theme(plot.title = element_text(size = 10, face = "bold"))
    
    # D28 Model cross-validation
    lambda_plot_d28 <- plot_lasso(cv_d28_pca, minOnly = TRUE) +
      labs(title = "Day 28 Sample Model") +
      theme(plot.title = element_text(size = 10, face = "bold"))
    
    lambda_plot_mod_d28 <- plot_lasso_mod(
        cv_d28_pca, custom_breaks = c(0, 5, 9, 15, 16), minOnly = TRUE) +
      theme(plot.title = element_text(size = 10, face = "bold"))
})

grid.arrange(
  grobs = list(
    model_analysis$lambda_plot_tdn, model_analysis$lambda_plot_d28), 
  nrow = 1)
```
Figure S6. Model optimization based on vector integration sites from infusion products or day 28 samples. A total of 91 features (Table S6) spanning population metrics, genomic features, and epigenetic features from 29 patients were used in least absolute shrinkage and selection operator (LASSO) logistic regression to build a classification model. Results from leave-one-out cross-validation of models based on transduction/pre-infusion products (A) and day 28 peripheral blood samples (B). The top horizontal numbers indicate the number of principal components used in the classification model, while the x-axis indicates the lambda constant used for tuning the model, and the y-axis shows misclassification error. Error bars indicated standard error. The minimum value of misclassification is indicated to the right of the plots.   

\newpage
## Supplemental Figure 7. Central Memory T-cell proportions within Infusion Products
```{r sup_fig_S07, fig.height=3, fig.width=5}
add_investigations$mem_subsets_plot
```
Figure S7. Central Memory T-cell proportions within Infusion Products. Proportion of central memory T-cells are shown for infusion products of CLL and ALL patients. Central Memory T-cells frequencies were identified at apheresis by the following markers: CD8+, CCR7+, and CD45RO+. Mean and standard error of the associated data are shown. No significant difference was identified between response groups within ALL or CLL as determined by a two-tailed T-test.  

\newpage
## Supplemental Figure 8. Disease specific analysis of integration site profiles
```{r sup_fig_S08, fig.height=6, fig.width=5}
add_investigations$disease_lasso_contrib_plot
```
Figure S8. Disease specific analysis of integration site profiles. A LASSO regression was used to identify variables within integration site profiles that would separate CLL and ALL patients. Analysis was performed on infusion products, and the percent contribution to the overall variance between the groups is displayed for values greater than 1%.

\newpage
## Supplemental Tables

### Supplemental Table S1. Patient Information.
Table S1. Patient metadata and results of integration site sequencing. 

```{r sup_tab_S1}
patient_sites_data <- all_sites %>%
  as.data.frame(row.names = NULL) %>%
  dplyr::mutate(posid = generate_posid(all_sites)) %>%
  dplyr::group_by(patient, samplename, posid) %>%
  dplyr::summarise(
    reads = sum(count), cells = n()
  ) %>%
  dplyr::group_by(patient) %>%
  dplyr::summarise(
    reads = sum(reads), cells = sum(cells), sites = n_distinct(posid)
  ) %>%
  dplyr::ungroup()

sup_tbl_s1 <- patient_data %>%
  dplyr::select(
    patient, disease, clin_trial, response, determinant_response
    ) %>%
  dplyr::filter(!is.na(response)) %>%
  dplyr::arrange(as.numeric(clin_trial), patient) %>%
  dplyr::mutate(
    determinant_response = gsub("_", "/", determinant_response),
    clin_trial = ifelse(
      clin_trial == "959", "CHP959", paste0("UPCC",clin_trial)
    ),
    response = gsub("\n", " ", response),
    response = gsub("w", "w/", response)
  ) %>%
  dplyr::left_join(patient_sites_data, by = "patient") %>%
  dplyr::rename(
    "Patient ID" = patient, "Disease" = disease, "Clin. Trial" = clin_trial, 
    "Response" = response, "Resp. Class" = determinant_response,
    "Reads" = reads, "Cells Sampled" = cells,
    "Unique Int. Sites" = sites
  )
  
write.csv(
  x = sup_tbl_s1, 
  file = file.path(outputDir, "sup_tbl_1_patient_info.csv"),
  quote = TRUE, 
  row.names = FALSE
)

knitr::kable(
    x = sup_tbl_s1, 
    format = "latex", booktabs = TRUE, longtable = TRUE
  ) %>%
  kableExtra::kable_styling(
    latex_options = c("hold_position", "repeat_header")
  ) %>%
  kableExtra::landscape()


```

\newpage
### Supplemental Table S2. Summary of patient ages in the CLL and ALL cohorts.
Table S2. Summary of patient ages in the CLL and ALL cohorts. We did not observe a significant correlation between age and clinical reponse within disease groups.
```{r sup_tbl_s2}
add_investigations$tdn_metrics %>% 
  dplyr::select(disease = rel_disease, age = Age_at_CAR_Tcell_Infusion) %>% 
  dplyr::group_by(disease) %>% 
  dplyr::summarise(
    mean = mean(age), median = median(age), sd = sd(age), se = sd / sqrt(n()), 
    min = min(age), max = max(age), n = n()
  ) %>% 
  dplyr::rename(
    "Disease" = disease, "Mean" = mean, "Median" = median, "Std. Dev." = sd, 
    "Std. Err." = se, "Minimum" = min, "Maximum" = max, "Count" = n
  ) %>%
  kable(format = "latex", booktabs = TRUE, digits = 1, align = "c") %>%
  kableExtra::kable_styling(latex_options = "hold_position")
```

\newpage
### Supplemental Table S3. Patient DNA samples analyzed by integration site sequencing.
Table S3. Table of specimens analyzed by vector integration site analysis.

```{r sup_tbl_S3}
specimen_sites_data <- all_sites %>%
  as.data.frame(row.names = NULL) %>%
  dplyr::mutate(posid = generate_posid(all_sites)) %>%
  dplyr::group_by(specimen, samplename, posid) %>%
  dplyr::summarise(
    reads = sum(count), cells = n()
  ) %>%
  dplyr::group_by(specimen) %>%
  dplyr::summarise(
    reads = sum(reads), cells = sum(cells), sites = n_distinct(posid)
  ) %>%
  dplyr::ungroup()

sup_tbl_s3 <- summaries$specimen %>%
  dplyr::select(specimen, patient, celltype, timepoint) %>%
  dplyr::filter(patient %in% sup_tbl_s1$`Patient ID`) %>%
  dplyr::arrange(specimen) %>%
  left_join(specimen_sites_data, by = "specimen") %>%
  dplyr::mutate(
    clin_trial = stringr::str_extract(patient, "[0-9]+"),
    clin_trial = ifelse(
      clin_trial == "959", "CHP959", paste0("UPCC", clin_trial))
  ) %>%
  dplyr::select(
    specimen, patient, clin_trial, celltype, 
    timepoint, reads, cells, sites
  ) %>%
  dplyr::rename(
    "GTSP ID" = specimen, "Patient ID" = patient, 
    "Clin. Trial" = clin_trial, "Cell Type" = celltype, 
    "Time Point" = timepoint, "Reads" = reads, "Cells Sampled" = cells,
    "Unique Int. Sites" = sites
  )
  
write.csv(
  x = sup_tbl_s3, 
  file = file.path(outputDir, "sup_tbl_3_specimen_info.csv"),
  quote = TRUE, 
  row.names = FALSE
)

knitr::kable(
    x = sup_tbl_s3, 
    format = "latex", booktabs = TRUE, longtable = TRUE
  ) %>%
  kableExtra::kable_styling(
    latex_options = c("hold_position", "repeat_header")
  ) %>%
  kableExtra::landscape()

```

\newpage
### Supplemental Table S4. Cancer-associated gene lists.
Table S4. Gene sets used for analysis, including cancer associated genes, human lymphoid cancer genes, and genes associated with clonal hematopoiesis, and overlaps between lists. Origins of gene lists are as follows: Bushman Lab allOnco List: (Sadelain et al., 2011, http://www.bushmanlab.org/links/genelists); Lymphoid cancer list: (personal communication, Marina Cavazzana, http://www.bushmanlab.org/links/genelists);  COSMIC: (Sondka, Z. et al. 2018 Nature Cancer Reviews), TCGA_Xie and Clonal_Hema_Xie (Xie, M. et al. 2014 Nature Medicine).

```{r sup_tbl_S4}
# Overlap table ----
print_mat <- ifelse(
  upper.tri(add_investigations$ovlpmat_gene_lists, diag = TRUE), 
  "", 
  format(add_investigations$ovlpmat_gene_lists, big.mark = ",")
)

rownames(print_mat) <- rownames(add_investigations$ovlpmat_gene_lists)
colnames(print_mat) <- add_investigations$shrt_list_names

print_df <- print_mat %>%
  as.data.frame() %>%
  dplyr::mutate(
    List = row.names(.),
    Size = sapply(add_investigations$reference_gene_lists, length)
  ) %>%
  dplyr::select(List, Size, everything(), -`Clonal Hema.`) %>%
  dplyr::mutate(
    PMID = c(
      "22129804", 
      "26590405",
      "personal corr.", 
      "30293088", 
      "25326804", 
      "25326804" 
    )
  )

print_df %>% 
  kable(
    format = "latex", booktabs = TRUE, align = c("l", rep("c", 7))
  ) %>%
  kableExtra::kable_styling(latex_options = c("hold_position", "scale_down"))
```

\newpage
### Supplmental Table S5. Statistical analysis of overlaps among genes called at integration sites and cancer associated gene lists.
Table S5. Statistical analysis of overlaps among genes called at integration sites and cancer associated gene lists in Table S4.

```{r sup_tab_S5}
# Enrichment within gene sets ----
add_investigations$compare_wide_frame %>%
  dplyr::rename("Criteria" = criteria, "Size" = size) %>%
  kable(
    format = "latex", booktabs = TRUE, align = c("l", "r", rep("c", 6))
  ) %>%
  kableExtra::kable_styling(latex_options = c("hold_position", "scale_down"))

```

\newpage
### Supplemental Table S6. Table of model variables
Table S6. 91 model variables used in the LASSO regression analysis.

```{r sup_tbl_S6}
sup_tbl_s6 <- read.csv(file.path(utilsDir, "feature_table.csv"))

sup_tbl_s6 %>%
  dplyr::select(
    "Group" = `Metric.Group`, "Abbv." = `Metric.Abbreviation`,
    "Description" = `Metric.Name...Description`,
    "Size (Kb)" = `Window.size..Kb.`, Source
  ) %>%
  knitr::kable(
    format = "latex", booktabs = TRUE, longtable = TRUE
  ) %>%
  kableExtra::kable_styling(
    latex_options = c("hold_position", "repeat_header"), 
    full_width = TRUE, 
    font_size = 9
  ) %>%
  kableExtra::column_spec(3, width = "30em") %>%
  kableExtra::landscape()

```



```{r ibru_predictions, eval=FALSE}
#\newpage
### Supplemental Table S4. Ibrutinib-based trial predictions
#Table S4. Predictions for Ibrutinib-based CART19 trial based on vector integration site analysis of infusion products.

ibru_analysis <- within(
  model_analysis, {

    ibru_data_set <- data.frame(
        patient = ibru_tdn_specimens$patient, 
        response = ibru_tdn_specimens$determinant_response,
        disease = ibru_tdn_specimens$disease,
        score = -predict(
          cv_tdn_pca, ibru_trans[,seq_len(tdn_pca_cutoff)])[, 1, drop = TRUE]
      ) %>%
      dplyr::mutate(
        pred = factor(
          ifelse(score > 0, "Positive", "Negative"), 
          levels = c("Positive", "Negative"))) %>%
      dplyr::group_by(response, pred) %>%
      dplyr::summarise(cnt = n()) %>%
      tidyr::spread(response, cnt, fill = 0) %>%
      dplyr::ungroup() %>%
      dplyr::rename(" " = pred, "CR/PRtd" = CR_PRtd, "PR/NR" = PR_NR)
    
  }
)

knitr::kable(
    x = ibru_analysis$ibru_data_set, 
    format = "latex", booktabs = TRUE) %>%
  kableExtra::kable_styling(latex_options = "hold_position") %>%
  kableExtra::add_header_above(
    header = c("Ibrutinib-trial Specimens" = 3)
  )

```

```{r sup_fig_SX1, fig.width=3, fig.height=3.5, eval=FALSE}
## Supplemental Figure 3. Integration enrichment of TET2 with and without expanded clone from patient 10

tet2_resp <- within(
  list(), {
    freq_rank <- dplyr::filter(
        gene_impact, 
        TP_num_patients >= 2,
        TP_num_sites >= 10,
        freq_diff > 0) %>%
      dplyr::arrange(desc(pct_chg)) %>%
      dplyr::mutate(id = seq_len(n())) %>%
      dplyr::group_by(id) %>%
      dplyr::mutate(fisher_test = {
        test <- fisher.test(
          matrix(
            c(TP_num_sites, total_pat_sites - TP_num_sites,
              TDN_num_sites, total_tdn_sites - TDN_num_sites), 
            ncol = 2))
        paste(
          c(test$p.value, test$estimate, as.numeric(test$conf.int)), 
          collapse = ":") }) %>%
      dplyr::ungroup() %>%
      tidyr::separate(
        col = fisher_test, 
        into = c("freq_fisher_pval", "freq_odds_ratio", 
                 "freq_conf_low", "freq_conf_high"), 
        sep = fixed(":"), remove = TRUE, convert = TRUE) %>%
      dplyr::mutate(adj_freq_test = p.adjust(freq_fisher_pval, method = "BH")) %>%
      dplyr::arrange(freq_fisher_pval) %>%
      dplyr::mutate(id = seq_len(n()))
    
    freq_rank_wo_TET2_clone <- dplyr::filter(
        gene_impact, 
        TP_num_patients >= 2,
        TP_num_sites >= 10,
        freq_diff > 0) %>%
      dplyr::arrange(desc(pct_chg)) %>%
      dplyr::mutate(
        TP_num_sites = ifelse(
          gene_name == "TET2", TP_num_sites - 1, TP_num_sites),
        id = seq_len(n())) %>%
      dplyr::group_by(id) %>%
      dplyr::mutate(fisher_test = {
        test <- fisher.test(
          matrix(
            c(TP_num_sites, total_pat_sites - TP_num_sites,
              TDN_num_sites, total_tdn_sites - TDN_num_sites), 
            ncol = 2))
        paste(
          c(test$p.value, test$estimate, as.numeric(test$conf.int)), 
          collapse = ":") }) %>%
      dplyr::ungroup() %>%
      tidyr::separate(
        col = fisher_test, 
        into = c("freq_fisher_pval", "freq_odds_ratio", 
                 "freq_conf_low", "freq_conf_high"), 
        sep = fixed(":"), remove = TRUE, convert = TRUE) %>%
      dplyr::mutate(adj_freq_test = p.adjust(freq_fisher_pval, method = "BH")) %>%
      dplyr::arrange(freq_fisher_pval) %>%
      dplyr::mutate(id = seq_len(n()))

    TET2_labels <- bind_rows(
        dplyr::filter(freq_rank, gene_name == "TET2"),
        dplyr::filter(freq_rank_wo_TET2_clone, gene_name == "TET2") %>%
          dplyr::mutate(gene_name = "TET2*"))
    # 4.5"x4.5"
    rank_order_plot <- freq_rank %>%
      dplyr::filter(freq_fisher_pval <= 0.05) %>%
      ggplot(aes(x = id, y = freq_odds_ratio)) +
      geom_point(
        aes(fill = freq_fisher_pval, size = TP_num_sites),
        color = "white", shape = 21) +
      geom_point(
        data = TET2_labels, 
        aes(fill = freq_fisher_pval, size = TP_num_sites), 
        color = "red", shape = 21) +
      geom_text_repel(
        data = TET2_labels,
        aes(label = gene_name), 
        nudge_x = 5, nudge_y = 1.0, segment.alpha = 0.5, 
        arrow = arrow(length = unit(0.05, "inches"))) +
      scale_fill_continuous(low = "#56B1F7", high = "#132B43") +
      guides(
        size = guide_legend(
          override.aes = list(color = "white", fill = "black"))) +
      labs(
        x = "Rank Order", 
        y = "Odds Ratio", 
        fill = "P-value", 
        size = "Identified\nClones") +
      custom_theme +
      theme(
        axis.line = element_line(color = "black"),
        legend.position = "right",
        legend.direction = "vertical", legend.box = "vertical")
    
    # 3"x3.5"
    tet2_resp_plot <- TET2_labels %>%
      dplyr::mutate(gene_name = ifelse(
        gene_name == "TET2", 
        "TET2\nwith\npatient 10", "TET2\nwithout\npatient 10")) %>%
      ggplot(aes(x = gene_name, y = freq_odds_ratio)) +
      geom_bar(stat = "identity", fill = "grey75", color = "black") +
      geom_point() +
      geom_linerange(aes(ymin = freq_conf_low, ymax = freq_conf_high)) +
      geom_hline(yintercept = 1.0, linetype = "dotted") +
      geom_hline(yintercept = 0.0) +
      labs(x = NULL, y = "Odds Ratio") +
      custom_theme +
      theme(
        axis.line.y = element_line(color = "black", size = 0.5),
        axis.line.x = element_blank(), 
        axis.ticks.x = element_blank())
  }
)

tet2_resp$tet2_resp_plot

#Figure S3. Enrichment of integration sites in the TET2 locus including (left) or not including (right) the expanded clone in patient 10, which is described in (12).  The dotted line indicates no enrichment. Error bars indicate 95% confidence intervals.

```

```{r sup_fig_SX2, fig.width=9, fig.height=3, out.width="80%", eval=FALSE}
## Supplemental Figure X. TET2 Clone behavior
#Figure S2. Longitudinal detection of clones harboring vector integration sites within the TET2 transcription unit. Relative abundance is determined by the proportion of sonic lengths measured for the specific clone compared to all other detected clones within the sample. Clones of repeated observations have their data points connected by a single line across time. Each clone is represented by a genomic coordinate, containing the sequence names (chr4, chromosome 4), the orientation of the integration, (+ / -, depending on the direction of the integrated vector with respect to the chromosomal indexing), and the nucleotide location on the chromosome.


tet2_clones <- within(
  list(), {
    
    tet2_sites <- cond_uniq_sites[subjectHits(GenomicRanges::findOverlaps(
      refGenes[refGenes$name2 == "TET2"], cond_uniq_sites
    ))]
    
    tet2_clone_data <- as.data.frame(tet2_sites, row.names = NULL) %>%
      dplyr::select(
        patient, timepoint, celltype, specimen, estAbund, relAbund, posid
      ) %>%
      dplyr::filter(celltype %in% c("PBL", "Tcells")) %>%
      dplyr::mutate(
        dtime = convert_time(as.character(timepoint)),
        dtime = ifelse(dtime == 0, 7.5, dtime),
        dtime = ifelse(dtime == 1, 8.5, dtime)
      ) %>%
      dplyr::group_by(patient, timepoint, dtime, celltype, posid) %>%
      dplyr::summarise(
        relAbund = max(relAbund),
        estAbund = max(estAbund)
      )
    
    clone_count_tbl <- tet2_clone_data %>%
      dplyr::distinct(patient, celltype, timepoint, dtime, estAbund) %>%
      dplyr::group_by(dtime, estAbund) %>%
      dplyr::summarise(cnt = n()) %>%
      dplyr::ungroup() %>%
      dplyr::filter(cnt > 1)
    
    axis_breaks <- c(
      7.5, 10, 14, 28, 60, 90, 120, 240, 365, 730, 1095, 1826
    )
    
    axis_labels <- c(
      "TDN", "d10", "d14", "d28", "m2", "m3", "m4", "m8", 
      "y1", "y2", "y3", "y5"
    )
    
    max_tp <- max(tet2_clone_data$dtime)
    max_idx <- min(which(axis_breaks > max_tp))
    max_idx <- max(c(max_idx, 5))
    
    axis_breaks <- axis_breaks[seq_len(max_idx)]
    axis_labels <- axis_labels[seq_len(max_idx)]
    
    clone_palette <- structure(
      colorRampPalette(RColorBrewer::brewer.pal(11, "Spectral"))(
        n = length(unique(tet2_clone_data$posid))
      ),
      names = sort(unique(tet2_clone_data$posid))
    )

    plot <- ggplot(tet2_clone_data, aes(x = dtime, y = relAbund)) +
      geom_line(aes(group = posid), alpha = 0.15) +
      geom_point(aes(fill = posid), color = "black", shape = 21, size = 2.5) +
      scale_fill_manual(values = clone_palette) +
      scale_x_log10(
        breaks = axis_breaks,
        labels = axis_labels,
        limits = c(7.5, max(tet2_clone_data$dtime))
      ) + 
      scale_y_log10(
        breaks = c(0.001, 0.01, 0.1, 1),
        labels = c(0.001, 0.01, 0.1, 1)
      ) +
      labs(
        x = "Treatment Time", 
        y = "Relative Abundance (Log-scale)", 
        fill = "Position ID"
      ) +
      guides(
        fill = guide_legend(
          direction = "vertical",
          keyheight = unit(0.27, units = "in"),
          nrow = 8
        )
      ) +
      custom_theme +
      theme(
        legend.position = "right",
        legend.text = element_text(size = 7.5),
        axis.line.y = element_line(color = "black"),
        axis.line.x = element_line(color = "black"),
        axis.text.x = element_text(size = 9),
        strip.text.y = element_text(angle = 0)
      )

    #ggsave(
    #    filename = "supfig.tet2_clones.long_plot.pdf", 
    #    plot = plot, 
    #    device = "pdf", 
    #    path = file.path(workingDir, "reports/manuscript_figures"), 
    #    width = 9, 
    #    height = 3, 
    #    units = "in"
    #  )
    
  }
)

tet2_clones$plot

```

```{r sup_fig_SX3, fig.width = 5, fig.height=3, eval=FALSE}
## Supplemental Figure 10. Sampling depth comparison between Infusion Products and Day 28 specimens

#Figure S10. Sampling depth across infusion products and day 28 peripheral blood samples. Saturation was calculated using the number if identified clones normalized by the Chao1 estimated population size. There was a significant diffence in the sampling of infusion products between disease groups (p-value = 0.0283, two-sided Wilcoxon Rank Sum Test), but there was no significant difference between groups of day 28 sampling. 


add_investigations$sampling_plot
add_investigations$sampling_wilcox %>%
  kable(format = "latex", booktabs = TRUE) %>%
  kableExtra::kable_styling(latex_options = "hold_position")
```

```{r additional_calcs, eval=FALSE}
## Comparision to Shifrut et al. 2018

shifrut_comparison <- within(
  list(), {
    
    # Check the overlap between the top genes identified from positive and 
    # negative effectors to T-cell growth.

    #gene_limit <- 25
    
    ## Supporting data from Shifrut et. al. 2018
    shifrut_gw_screen <- data.table::fread(
      paste0("zcat ", file.path(utilsDir, "gw_SLICE_exp_data.csv.gz")),
      data.table = FALSE
    )
    
    shifrut_rep_screen <- data.table::fread(
      paste0("zcat ", file.path(utilsDir, "rep_SLICE_exp_data.csv.gz")),
      data.table = FALSE
    )

    # Make sure the gene names are consistent across datasets
    shifrut_screen_genes <- alias_arbiter(
      IDs = unique(shifrut_rep_screen$id), 
      RefIDs = hgnc_complete$symbol,
      aliasIDs = hgnc_complete$extended_alias,
      sep = "|", 
      remove_absent_IDs = NULL, 
      quiet = TRUE
    )
    
    total_overlapping_genes <- intersect(
      gene_impact$gene_name, shifrut_screen_genes
    )

    ### Identify reproducible negatively associated genes
    shifrut_neg_genes <- dplyr::arrange(
        shifrut_rep_screen, `neg|fdr`, `neg|score`
      ) %>%
      dplyr::filter(`neg|fdr` <= 0.05)
    
    shifrut_neg_genes <- alias_arbiter(
      IDs = shifrut_neg_genes$id, 
      RefIDs = hgnc_complete$symbol,
      aliasIDs = hgnc_complete$extended_alias,
      sep = "|", 
      remove_absent_IDs = NULL, 
      quiet = TRUE
    )
    
    ### Identify reproducible positively associated genes
    shifrut_pos_genes <- dplyr::arrange(
        shifrut_rep_screen, `pos|fdr`, `pos|score`
      ) %>%
      dplyr::filter(`pos|fdr` <= 0.05)

    shifrut_pos_genes <- alias_arbiter(
      IDs = shifrut_pos_genes$id, 
      RefIDs = hgnc_complete$symbol,
      aliasIDs = hgnc_complete$extended_alias,
      sep = "|", 
      remove_absent_IDs = NULL, 
      quiet = TRUE
    )
    
    # Create list object of genes
    goi_analysis <- read.csv(
        file.path(
          outputDir, 
          grep("_cart19_goi_data.csv", list.files(outputDir), value = TRUE)
        )
      ) %>%
      dplyr::mutate(Gene_Name = gsub("'", "", Gene_Name)) 

    # GOI potential genes and analysis ----   
    potential_genes <- apply(
      as.matrix(goi_analysis[
        ,c("Depletion", "Enrichment", "Abundance", "Longitudinal")]), 
      2, function(x){
             goi_analysis$Gene_Name[x]
           })
    
    depletion_genes <- potential_genes$Depletion
    
    composite_genes <- unique(unlist(
      potential_genes[c("Enrichment", "Abundance", "Longitudinal")]))

    # Compare depletion genes to negative and composite genes to positive

    stats_tbl <- dplyr::bind_rows(lapply(
          c(1:2), 
          function(i, genes, pos_genes, neg_genes, total_considered){
            
            gene_set <- genes[[i]]
            
            # Normalize lists
            gene_set <- gene_set[gene_set %in% total_considered]
            not_gene_set <- total_considered[!total_considered %in% gene_set]
            
            if(i == 1){
              shi_genes <- neg_genes[neg_genes %in% total_considered]
            }else{
              shi_genes <- pos_genes[pos_genes %in% total_considered]
            }
            
            not_shi_genes <- total_considered[!total_considered %in% shi_genes]
            
            # Generate matrices
            gene_mat <- matrix(
              c(
                length(intersect(gene_set, shi_genes)),
                length(intersect(not_gene_set, shi_genes)),
                length(intersect(gene_set, not_shi_genes)),
                length(intersect(not_gene_set, not_shi_genes))
              ),
              ncol = 2
            )
            
            # Construct output data.frame
            data.frame(
              "gene.set" = names(genes)[[i]],
              "set.size" = length(gene_set),
              "shi.size" = length(shi_genes),
              "ovlp.size" = length(intersect(gene_set, shi_genes)),
              "enrich.odds" = fisher.test(gene_mat)$estimate,
              "enrich.pval" = fisher.test(gene_mat)$p.value,
              "ovlp.genes" = paste(
                intersect(gene_set, shi_genes), collapse = ";"
              )
            )
            
          },
          genes = list(
            "Depletion" = depletion_genes, "Composite" = composite_genes
          ),
          pos_genes = shifrut_pos_genes,
          neg_genes = shifrut_neg_genes,
          total_considered = total_overlapping_genes
        )
      )

  }
)

pander::pandoc.table(
  shifrut_comparison$stats_tbl, style = "simple", digits = 3, split.table = Inf
)
```

